"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[56411],{24889:(t,e,n)=>{n.d(e,{SZ:()=>s,e8:()=>o,hm:()=>i});var r=n(42761);const s=(0,r.O)()({RSP_NearestNeighbor:"nearest",RSP_BilinearInterpolation:"bilinear",RSP_CubicConvolution:"cubic",RSP_Majority:"majority"}),i=(0,r.O)()({esriNoDataMatchAny:"any",esriNoDataMatchAll:"all"}),o=(0,r.O)()({U1:"u1",U2:"u2",U4:"u4",U8:"u8",S8:"s8",U16:"u16",S16:"s16",U32:"u32",S32:"s32",F32:"f32",F64:"f64",C64:"c64",C128:"c128",UNKNOWN:"unknown"})},33778:(t,e,n)=>{n.d(e,{A:()=>c});var r,s=n(93800),i=n(48602),o=(n(21265),n(50925),n(14746),n(47332)),a=n(75269),l=n(64473);let f=r=class extends l.A{constructor(){super(...arguments),this.type="gcs-shift",this.tolerance=1e-8}forwardTransform(t){return"point"===(t=t.clone()).type?(t.x>180+this.tolerance&&(t.x-=360),t):(t.xmin>=180-this.tolerance?(t.xmax-=360,t.xmin-=360):t.xmax>180+this.tolerance&&(t.xmin=-180,t.xmax=180),t)}inverseTransform(t){return"point"===(t=t.clone()).type?(t.x<-this.tolerance&&(t.x+=360),t):(t.xmin<-this.tolerance&&(t.xmin+=360,t.xmax+=360),t)}clone(){return new r({tolerance:this.tolerance})}};(0,s._)([(0,o.e)({GCSShiftXform:"gcs-shift"})],f.prototype,"type",void 0),(0,s._)([(0,i.MZ)()],f.prototype,"tolerance",void 0),f=r=(0,s._)([(0,a.$)("esri.layers.support.rasterTransforms.GCSShiftTransform")],f);const c=f},47659:(t,e,n)=>{n.d(e,{DP:()=>y,Nh:()=>g,Pg:()=>x,RP:()=>c,WF:()=>f,_N:()=>v,eH:()=>h,f4:()=>d,fP:()=>m,zj:()=>u});var r=n(17741),s=n(61531),i=n(82518),o=n(70943);const a=1,l=[.299,.587,.114];function f(t){let e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:256;e=Math.min(e,256);const{size:n,counts:r}=t,s=new Uint8Array(n),i=r.reduce(((t,n)=>t+n/e),0);let o=0,a=0,l=0,f=i;for(let c=0;c<n;c++)if(l+=r[c],!(c<n-1&&l+r[c+1]<f)){for(;o<e-1&&f<l;)o++,f+=i;for(let t=a;t<=c;t++)s[t]=o;a=c+1}for(let c=a;c<n;c++)s[c]=e-1;return s}function c(t){const{minCutOff:e,maxCutOff:n,gamma:r,pixelType:s,rounding:i}=t;if(!["u8","u16","s8","s16"].includes(s))return null;const o=e.length,a="s8"===s?-127:"s16"===s?-32767:0,l=["u16","s16"].includes(s)?65536:256,f=[],c=[],{minOutput:m=0,maxOutput:p=255}=t,h=p-m;for(let u=0;u<o;u++)c[u]=n[u]-e[u],f[u]=0===c[u]?0:h/c[u];const d=[];if(r&&r.length>=o){const t=g(o,r);for(let s=0;s<o;s++){const o=[];for(let f=0;f<l;f++){if(0===c[s]){o[f]=m;continue}const l=f+a,u=(l-e[s])/c[s];let d=1;if(r[s]>1&&(d-=(1/h)**(u*t[s])),l<n[s]&&l>e[s]){const t=d*h*u**(1/r[s])+m;o[f]="floor"===i?Math.floor(t):"round"===i?Math.round(t):t}else l>=n[s]?o[f]=p:o[f]=m}d[s]=o}}else for(let u=0;u<o;u++){const t=[];for(let r=0;r<l;r++){const s=r+a;if(s<=e[u])t[r]=m;else if(s>=n[u])t[r]=p;else{const n=(s-e[u])*f[u]+m;t[r]="floor"===i?Math.floor(n):"round"===i?Math.round(n):n}}d[u]=t}if(null!=t.contrastOffset){const e=u(t.contrastOffset,t.brightnessOffset);for(let t=0;t<o;t++){const n=d[t];for(let t=0;t<l;t++)n[t]=e[n[t]]}}return{lut:d,offset:a}}function u(t,e){const n=Math.min(Math.max(t,-100),100),r=Math.min(Math.max(e??0,-100),100),s=255,i=new Uint8Array(256);for(let o=0;o<256;o++){let t=0;n>0&&n<100?t=(200*o-25500+510*r)/(2*(100-n))+128:n<=0&&n>-100?t=(200*o-25500+510*r)*(100+n)/2e4+128:100===n?(t=200*o-25500+256*(100-n)+510*r,t=t>0?s:0):-100===n&&(t=128),i[o]=t>s?s:t<0?0:t}return i}function m(t,e,n){const r=[];for(let s=0;s<e.length;s++){let i=0,o=0,a=0;"min"in e[s]?({min:i,max:o,avg:a}=e[s]):[i,o,a]=e[s];let f=a??0;"u8"!==t&&(f=255*(f-i)/(o-i)),n&&(f*=l[s]),r.push(p(f))}return r}function p(t){if(t<=0||t>=255)return a;const e=t+(150===t?0:t<150?45*Math.cos(.01047*t):17*Math.sin(.021*t)),n=Math.log(t/255),r=Math.log(e/255);if(0===r)return a;const s=n/r;return isNaN(s)?a:Math.min(9.9,Math.max(.01,s))}function h(t){const{pixels:e,mask:n,pixelType:r,bandMasks:s}=t,i=e.map(((t,e)=>function(t,e,n){let r=1/0,s=-1/0,i=0,o=0,a=0,l=0;const f=t.length,c=new Map,u=[];for(let O=0;O<f;O++){const n=t[O];if(!e||e[O]){u.push(n);const t=(c.get(n)??0)+1;c.set(n,t),t>l&&(l=t,a=n),r=n<r?n:r,s=n>s?n:s,i+=n,o++}}if(0===o)return{statistics:{min:0,max:0,avg:0,stddev:0,mode:0,median:0},histogram:null};const m=i/o;let p=0;for(let O=0;O<f;O++)e&&!e[O]||(p+=(t[O]-m)**2);const h=e?e.filter((t=>t)).length:f,d=h<=1?0:Math.sqrt(p/(h-1));u.sort(((t,e)=>t-e));const x=o>>>1,y={min:r,max:s,avg:m,stddev:d,mode:a,median:o%2?u[Math.floor(x)]:(u[x-1]+u[x])/2};if(["u8","s8","u4","u2","u1"].includes(n)){const n=s-r+1,i=new Uint32Array(n);for(let s=0;s<f;s++)e&&!e[s]||i[t[s]-r]++;return{statistics:y,histogram:{min:r-.5,max:s+.5,size:n,counts:i}}}const g=256,v=new Uint32Array(g),w=(s-r)/g;if(0===w)return{statistics:y,histogram:{min:r,max:s,size:1,counts:new Uint32Array(1).fill(o)}};const C=new Uint32Array(257);for(let O=0;O<f;O++)e&&!e[O]||C[Math.floor((t[O]-r)/w)]++;for(let O=0;O<255;O++)v[O]=C[O];return v[255]=C[255]+C[g],{statistics:y,histogram:{min:r,max:s,size:g,counts:v}}}(t,s?.[e]??n,r)));return{statistics:i.map((t=>{let{statistics:e}=t;return e})),histograms:i.map((t=>{let{histogram:e}=t;return e}))}}function d(t){if(!t?.pixels?.length)return null;const{pixels:e,mask:n,bandMasks:r,pixelType:s}=t,i=t.width*t.height,o=e.length,a=[],l=[],f=256;let c,u;for(let m=0;m<o;m++){let o=new Uint32Array(f);const p=e[m],h=r?.[m]??n;if("u8"===s){if(c=255,u=0,h){for(let t=0;t<i;t++)if(h[t]){const e=p[t];c=e<c?e:c,u=e>u?e:u,o[e]++}}else for(let t=0;t<i;t++){const e=p[t];c=e<c?e:c,u=e>u?e:u,o[e]++}o=o.slice(c,u+1)}else{let e=!1;t.statistics||(t.updateStatistics(),e=!0);const n=t.statistics;c=n[m].minValue,u=n[m].maxValue;const r=(u-c)/f;if(0===r){!n||t.validPixelCount||e||t.updateStatistics();const r=(t.validPixelCount||t.width*t.height)/f;for(let t=0;t<f;t++)o[t]=Math.round(r*(t+1))-Math.round(r*t)}else{const t=new Uint32Array(257);for(let e=0;e<i;e++)h&&!h[e]||t[Math.floor((p[e]-c)/r)]++;for(let e=0;e<255;e++)o[e]=t[e];o[255]=t[255]+t[f]}}const d="u8"===s?c-.5:c,x="u8"===s?u+.5:u;a.push({min:d,max:x,size:o.length,counts:o});let y=0,g=0,v=0;for(let t=0;t<o.length;t++)y+=o[t],g+=t*o[t];const w=g/y;for(let t=0;t<o.length;t++)v+=o[t]*(t-w)**2;const C=Math.sqrt(v/(y-1)),O=(x-d)/o.length,S=(w+("u8"===s?0:.5))*O+c,M=C*O;l.push({min:c,max:u,avg:S,stddev:M})}return{statistics:l,histograms:a}}function x(t){const e=[];for(let n=0;n<t.length;n++){const{min:r,max:s,size:i,counts:o}=t[n];let a=0,l=0;for(let t=0;t<i;t++)a+=o[t],l+=t*o[t];const f=l/a;let c=0;for(let t=0;t<i;t++)c+=o[t]*(t-f)**2;const u=(s-r)/i,m=(f+.5)*u+r,p=Math.sqrt(c/(a-1))*u;e.push({min:r,max:s,avg:m,stddev:p})}return e}function y(t,e){const{pixelBlock:n,bandIds:s,returnHistogramLut:a,rasterInfo:l}=e;let c=null,u=null,m=t.stretchType;if("number"==typeof m&&(m=o.x[m]),t.dra)if("minMax"===m&&n?.statistics)c=n.statistics.map((t=>[t.minValue,t.maxValue,0,0]));else{const t=d(n);c=null!=t?t.statistics:null,u=null!=t?t.histograms:null}else c=t.statistics?.length?t.statistics:l.statistics,u="histograms"in t?t.histograms:void 0,u||(u=l.histograms);"percentClip"!==m&&"histogramEqualization"!==m||u?.length||(m="minMax");const p=c?.length||u?.length||l.bandCount,h=[],x=[];c&&!Array.isArray(c[0])&&(c=c.map((t=>[t.min,t.max,t.avg,t.stddev])));const[y,g]=(0,i.hP)(l.pixelType);if(!c?.length){c=[];for(let t=0;t<p;t++)c.push([y,g,1,1]);"standardDeviation"===m&&(m="minMax")}switch(m){case"none":for(let t=0;t<p;t++)h[t]=y,x[t]=g;break;case"minMax":for(let t=0;t<p;t++){const e=c[t];h[t]=e[0],x[t]=e[1]}break;case"standardDeviation":{const{numberOfStandardDeviations:e=2}=t;for(let t=0;t<p;t++){const n=c[t];h[t]=n[2]-e*n[3],x[t]=n[2]+e*n[3],h[t]<n[0]&&(h[t]=n[0]),x[t]>n[1]&&(x[t]=n[1])}}break;case"histogramEqualization":(0,r.Lw)(u);for(let t=0;t<p;t++)h[t]=u[t].min,x[t]=u[t].max;break;case"percentClip":(0,r.Lw)(u);for(let e=0;e<u.length;e++){const n=u[e],r=new Uint32Array(n.size),s=[...n.counts];s.length>=20&&(s[0]=s[1]=s[2]=s[s.length-1]=s[s.length-2]=0);let i=0;const o=(n.max-n.min)/n.size,a=-.5===n.min&&1===o?.5:0;for(let t=0;t<n.size;t++)i+=s[t],r[t]=i;let l=(t.minPercent||0)*i/100;h[e]=n.min+a;for(let t=0;t<n.size;t++)if(r[t]>l){h[e]=n.min+o*(t+a);break}l=(1-(t.maxPercent||0)/100)*i,x[e]=n.max+a;for(let t=n.size-2;t>=0;t--)if(r[t]<l){x[e]=n.min+o*(t+2-a);break}if(x[e]<h[e]){const t=h[e];h[e]=x[e],x[e]=t}}break;default:for(let t=0;t<p;t++){const e=c[t];h[t]=e[0],x[t]=e[1]}}let v,w,C;return"histogramEqualization"===m?((0,r.Lw)(u),w=u[0].size||256,v=0,a&&(C=u.map((t=>f(t))))):(w=t.max||255,v=t.min||0),function(t,e){if(null==e||0===e.length)return t;const n=Math.max.apply(null,e),{minCutOff:r,maxCutOff:s,minOutput:i,maxOutput:o,histogramLut:a}=t;return r.length===e.length||r.length<=n?t:{minCutOff:e.map((t=>r[t])),maxCutOff:e.map((t=>s[t])),histogramLut:a?e.map((t=>a[t])):null,minOutput:i,maxOutput:o}}({minCutOff:h,maxCutOff:x,maxOutput:w,minOutput:v,histogramLut:C},s)}function g(t,e){const n=new Float32Array(t);for(let r=0;r<t;r++)e[r]>1?e[r]>2?n[r]=6.5+(e[r]-2)**2.5:n[r]=6.5+100*(2-e[r])**4:n[r]=1;return n}function v(t,e){if(!t?.pixels?.length)return t;const{mask:n,bandMasks:r,width:i,height:o,pixels:a}=t,{minCutOff:l,maxCutOff:f,minOutput:c,maxOutput:u,gamma:m}=e,p=i*o,h=e.outputPixelType||"u8",d=t.pixels.map((()=>s.default.createEmptyBand(h,p))),x=d.length,y=u-c,v=[],w=[];for(let s=0;s<x;s++)w[s]=f[s]-l[s],v[s]=0===w[s]?0:y/w[s];const C=h.startsWith("u")||h.startsWith("s"),O=m&&m.length>=x,S=!!e.isRenderer;if(O){const t=g(x,m);for(let e=0;e<x;e++){const s=r?.[e]??n;for(let n=0;n<p;n++)if(null==s||s[n]){if(0===w[e]){d[e][n]=c;continue}const r=a[e][n],s=(r-l[e])/w[e];let i=1;if(m[e]>1&&(i-=(1/y)**(s*t[e])),r<f[e]&&r>l[e]){const t=i*y*s**(1/m[e])+c;d[e][n]=S?Math.floor(t):C?Math.round(t):t}else r>=f[e]?d[e][n]=u:d[e][n]=c}}}else for(let s=0;s<x;s++){const t=r?.[s]??n;for(let e=0;e<p;e++)if(null==t||t[e]){const t=a[s][e];if(t<f[s]&&t>l[s]){const n=(t-l[s])*v[s]+c;d[s][e]=S?Math.floor(n):C?Math.round(n):n}else t>=f[s]?d[s][e]=u:d[s][e]=c}}const M=new s.default({width:i,height:o,mask:n,bandMasks:r,pixels:d,pixelType:h});return M.updateStatistics(),M}},56175:(t,e,n)=>{n.d(e,{A:()=>x});var r,s=n(93800),i=n(48602),o=(n(21265),n(50925),n(14746),n(47332)),a=n(14800),l=n(75269),f=n(15484),c=n(12560),u=n(75400),m=n(64473);function p(t,e,n){const{x:r,y:s}=e;if(n<2)return{x:t[0]+r*t[2]+s*t[4],y:t[1]+r*t[3]+s*t[5]};if(2===n){const e=r*r,n=s*s,i=r*s;return{x:t[0]+r*t[2]+s*t[4]+e*t[6]+i*t[8]+n*t[10],y:t[1]+r*t[3]+s*t[5]+e*t[7]+i*t[9]+n*t[11]}}const i=r*r,o=s*s,a=r*s,l=i*r,f=i*s,c=r*o,u=s*o;return{x:t[0]+r*t[2]+s*t[4]+i*t[6]+a*t[8]+o*t[10]+l*t[12]+f*t[14]+c*t[16]+u*t[18],y:t[1]+r*t[3]+s*t[5]+i*t[7]+a*t[9]+o*t[11]+l*t[13]+f*t[15]+c*t[17]+u*t[19]}}function h(t,e,n){const{xmin:r,ymin:s,xmax:i,ymax:o,spatialReference:a}=e;let l=[];if(n<2)l.push({x:r,y:o}),l.push({x:i,y:o}),l.push({x:r,y:s}),l.push({x:i,y:s});else{let t=10;for(let e=0;e<t;e++)l.push({x:r,y:s+(o-s)*e/(t-1)}),l.push({x:i,y:s+(o-s)*e/(t-1)});t=8;for(let e=1;e<=t;e++)l.push({x:r+(i-r)*e/t,y:s}),l.push({x:r+(i-r)*e/t,y:o})}l=l.map((e=>p(t,e,n)));const f=l.map((t=>t.x)),u=l.map((t=>t.y));return new c.default({xmin:Math.min.apply(null,f),xmax:Math.max.apply(null,f),ymin:Math.min.apply(null,u),ymax:Math.max.apply(null,u),spatialReference:a})}let d=r=class extends m.A{constructor(){super(...arguments),this.polynomialOrder=1,this.type="polynomial"}readForwardCoefficients(t,e){const{coeffX:n,coeffY:r}=e;if(!n?.length||!r?.length||n.length!==r.length)return null;const s=[];for(let i=0;i<n.length;i++)s.push(n[i]),s.push(r[i]);return s}writeForwardCoefficients(t,e,n){const r=[],s=[];for(let i=0;i<t?.length;i++)i%2==0?r.push(t[i]):s.push(t[i]);e.coeffX=r,e.coeffY=s}get inverseCoefficients(){let t=this._get("inverseCoefficients");const e=this._get("forwardCoefficients");return!t&&e&&this.polynomialOrder<2&&(t=function(t){const[e,n,r,s,i,o]=t,a=r*o-i*s,l=i*s-r*o;return[(i*n-e*o)/a,(r*n-e*s)/l,o/a,s/l,-i/a,-r/l]}(e)),t}set inverseCoefficients(t){this._set("inverseCoefficients",t)}readInverseCoefficients(t,e){const{inverseCoeffX:n,inverseCoeffY:r}=e;if(!n?.length||!r?.length||n.length!==r.length)return null;const s=[];for(let i=0;i<n.length;i++)s.push(n[i]),s.push(r[i]);return s}writeInverseCoefficients(t,e,n){const r=[],s=[];for(let i=0;i<t?.length;i++)i%2==0?r.push(t[i]):s.push(t[i]);e.inverseCoeffX=r,e.inverseCoeffY=s}get affectsPixelSize(){return this.polynomialOrder>0}forwardTransform(t){if("point"===t.type){const e=p(this.forwardCoefficients,t,this.polynomialOrder);return new u.default({x:e.x,y:e.y,spatialReference:t.spatialReference})}return h(this.forwardCoefficients,t,this.polynomialOrder)}inverseTransform(t){if("point"===t.type){const e=p(this.inverseCoefficients,t,this.polynomialOrder);return new u.default({x:e.x,y:e.y,spatialReference:t.spatialReference})}return h(this.inverseCoefficients,t,this.polynomialOrder)}clone(){return new r({polynomialOrder:this.polynomialOrder,forwardCoefficients:this.forwardCoefficients?[...this.forwardCoefficients]:null,inverseCoefficients:this.inverseCoefficients?[...this.inverseCoefficients]:null})}};(0,s._)([(0,i.MZ)({json:{write:!0}})],d.prototype,"polynomialOrder",void 0),(0,s._)([(0,i.MZ)()],d.prototype,"forwardCoefficients",void 0),(0,s._)([(0,a.w)("forwardCoefficients",["coeffX","coeffY"])],d.prototype,"readForwardCoefficients",null),(0,s._)([(0,f.K)("forwardCoefficients")],d.prototype,"writeForwardCoefficients",null),(0,s._)([(0,i.MZ)({json:{write:!0}})],d.prototype,"inverseCoefficients",null),(0,s._)([(0,a.w)("inverseCoefficients",["inverseCoeffX","inverseCoeffY"])],d.prototype,"readInverseCoefficients",null),(0,s._)([(0,f.K)("inverseCoefficients")],d.prototype,"writeInverseCoefficients",null),(0,s._)([(0,i.MZ)()],d.prototype,"affectsPixelSize",null),(0,s._)([(0,o.e)({PolynomialXform:"polynomial"})],d.prototype,"type",void 0),d=r=(0,s._)([(0,l.$)("esri.layers.support.rasterTransforms.PolynomialTransform")],d);const x=d},64473:(t,e,n)=>{n.d(e,{A:()=>l});var r=n(93800),s=n(19455),i=n(48602),o=(n(21265),n(50925),n(14746),n(75269));let a=class extends s.A{get affectsPixelSize(){return!1}forwardTransform(t){return t}inverseTransform(t){return t}};(0,r._)([(0,i.MZ)()],a.prototype,"affectsPixelSize",null),(0,r._)([(0,i.MZ)({json:{write:!0}})],a.prototype,"spatialReference",void 0),a=(0,r._)([(0,o.$)("esri.layers.support.rasterTransforms.BaseRasterTransform")],a);const l=a},70943:(t,e,n)=>{n.d(e,{u:()=>r,x:()=>s});const r=new(n(42761).J)({none:"none",standardDeviation:"standard-deviation",histogramEqualization:"histogram-equalization",minMax:"min-max",percentClip:"percent-clip",sigmoid:"sigmoid"}),s={0:"none",3:"standardDeviation",4:"histogramEqualization",5:"minMax",6:"percentClip",9:"sigmoid"}},81759:(t,e,n)=>{function r(t){return["u8","s8"].includes(t.pixelType)&&null!=t.statistics?.[0]?.min&&null!=t.statistics[0]?.max&&1===t.bandCount}function s(t,e){const{attributeTable:n,bandCount:s}=t;return!(null!=n||!r(t))||!(null==n||s>1)&&(!e||null!=n.fields.find((t=>t.name.toLowerCase()===e.toLowerCase())))}function i(t){const{bandCount:e,dataType:n,pixelType:r}=t;return"elevation"===n||"generic"===n&&1===e&&("s16"===r||"s32"===r||"f32"===r||"f64"===r)}function o(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const{bandCount:n,colormap:r,pixelType:s}=t;return 1===n&&(!!r?.length||!e&&"u8"===s)}function a(t){let e=arguments.length>1&&void 0!==arguments[1]&&arguments[1];const{attributeTable:n,bandCount:r}=t;return 1===r&&(!e||null!=n||null!=t.histograms)}function l(t){const{dataType:e}=t;return"vector-uv"===e||"vector-magdir"===e}function f(t){const{dataType:e}=t;return"vector-uv"===e||"vector-magdir"===e}function c(t){return!!t?.length&&t.length<=16384}n.d(e,{FA:()=>o,QJ:()=>f,WN:()=>c,bo:()=>r,hu:()=>s,iL:()=>i,rd:()=>l,xX:()=>a})},95981:(t,e,n)=>{n.r(e),n.d(e,{default:()=>z});var r,s=n(12560),i=n(75400),o=n(78178),a=n(61531),l=n(51971),f=n(50396),c=n(65231),u=n(90801),m=n(47659),p=n(21543),h=n(33778),d=n(93800),x=(n(50925),n(21265),n(14746),n(74719),n(47332)),y=n(75269),g=n(64473);let v=r=class extends g.A{constructor(){super(...arguments),this.type="identity"}clone(){return new r}};(0,d._)([(0,x.e)({IdentityXform:"identity"})],v.prototype,"type",void 0),v=r=(0,d._)([(0,y.$)("esri.layers.support.rasterTransforms.IdentityTransform")],v);const w=v;var C=n(56175);const O={GCSShiftXform:h.A,IdentityXform:w,PolynomialXform:C.A};function S(t){const e=t?.type;if(!e)return null;const n=O[t?.type];if(n){const e=new n;return e.read(t),e}return null}var M=n(27181),b=n(65078);class z{convertVectorFieldData(t){const e=a.default.fromJSON(t.pixelBlock),n=(0,p.FI)(e,t.type);return Promise.resolve(null!=n?n.toJSON():null)}computeStatisticsHistograms(t){const e=a.default.fromJSON(t.pixelBlock),n=(0,m.eH)(e);return Promise.resolve(n)}async decode(t){const e=await(0,l.D)(t.data,t.options);return e&&e.toJSON()}symbolize(t){t.pixelBlock=a.default.fromJSON(t.pixelBlock),t.extent=t.extent?s.default.fromJSON(t.extent):null;const e=this.symbolizer.symbolize(t);return Promise.resolve(null!=e?e.toJSON():null)}async updateSymbolizer(t){this.symbolizer=M.A.fromJSON(t.symbolizerJSON),t.histograms&&"rasterStretch"===this.symbolizer?.rendererJSON.type&&(this.symbolizer.rendererJSON.histograms=t.histograms)}async updateRasterFunction(t){this.rasterFunction=(0,c.vt)(t.rasterFunctionJSON)}async process(t){const e=this.rasterFunction.process({extent:s.default.fromJSON(t.extent),primaryPixelBlocks:t.primaryPixelBlocks.map((t=>null!=t?a.default.fromJSON(t):null)),primaryPixelSizes:t.primaryPixelSizes?.map((t=>null!=t?i.default.fromJSON(t):null)),primaryRasterIds:t.primaryRasterIds});return null!=e?e.toJSON():null}stretch(t){const e=this.symbolizer.simpleStretch(a.default.fromJSON(t.srcPixelBlock),t.stretchParams);return Promise.resolve(e?.toJSON())}estimateStatisticsHistograms(t){const e=(0,m.f4)(a.default.fromJSON(t.srcPixelBlock));return Promise.resolve(e)}split(t){const e=(0,f.lD)(a.default.fromJSON(t.srcPixelBlock),t.tileSize,t.maximumPyramidLevel??0,!1===t.useBilinear);return e&&e.forEach(((t,n)=>{e.set(n,t?.toJSON())})),Promise.resolve(e)}clipTile(t){const e=a.default.fromJSON(t.pixelBlock),n=(0,f.J$)({...t,pixelBlock:e});return Promise.resolve(n?.toJSON())}async mosaicAndTransform(t){const e=t.srcPixelBlocks.map((t=>t?new a.default(t):null)),n=(0,f.z7)(e,t.srcMosaicSize,{blockWidths:t.blockWidths,alignmentInfo:t.alignmentInfo,clipOffset:t.clipOffset,clipSize:t.clipSize});let r,s=n;return t.coefs&&(s=(0,f.$i)(n,t.destDimension,t.coefs,t.sampleSpacing,t.interpolation)),t.projectDirections&&t.gcsGrid&&(r=(0,f.QF)(t.destDimension,t.gcsGrid),s=(0,p.Y2)(s,t.isUV?"vector-uv":"vector-magdir",r)),{pixelBlock:s?.toJSON(),localNorthDirections:r}}async createFlowMesh(t,e){const n={data:new Float32Array(t.flowData.buffer),mask:new Uint8Array(t.flowData.maskBuffer),width:t.flowData.width,height:t.flowData.height},{vertexData:r,indexData:s}=await(0,b.CW)(t.meshType,t.simulationSettings,n,e.signal);return{result:{vertexBuffer:r.buffer,indexBuffer:s.buffer},transferList:[r.buffer,s.buffer]}}async getProjectionOffsetGrid(t){const e=s.default.fromJSON(t.projectedExtent),n=s.default.fromJSON(t.srcBufferExtent);let r=null;t.datumTransformationSteps&&(r=new o.default({steps:t.datumTransformationSteps})),(t.includeGCSGrid||(0,u.xh)(e.spatialReference,n.spatialReference,r))&&await(0,u.Hh)();const i=t.rasterTransform?S(t.rasterTransform):null;return(0,u.l0)({...t,projectedExtent:e,srcBufferExtent:n,datumTransformation:r,rasterTransform:i})}}}}]);