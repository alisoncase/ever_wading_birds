"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[2862,22290,28659,98891],{2862:(t,e,s)=>{s.r(e),s.d(e,{fromExtent:()=>x,fromGeometry:()=>d,fromMultipoint:()=>E,fromPoint:()=>v,fromPolygon:()=>T,fromPolyline:()=>A,fromSpatialReference:()=>C,getSpatialReference:()=>f,toExtent:()=>w,toGeometry:()=>P,toMultipoint:()=>S,toPoint:()=>G,toPolygon:()=>N,toPolyline:()=>b});var r=s(54256),n=(s(45204),s(9270)),i=s(12834),o=s(65889),a=s(75646),l=s(12560),u=s(76493),m=s(75400),c=s(65920),h=s(54824),p=(s(3016),s(5410));const g="_gxVersion",_=2,y=1;function f(t){return Array.isArray(t)?t[0].spatialReference:t.spatialReference}function d(t){switch(t.type){case"point":return v(t);case"multipoint":return E(t);case"polyline":return A(t);case"polygon":return T(t);case"extent":return x(t);default:throw new Error(`Unsupported geometry type: ${t.type}`)}}function x(t){if(!t.getCacheValue(g)){const e=new i.E;e.setCoords(t.xmin,t.ymin,t.xmax,t.ymax),t.hasM&&e.setInterval(_,0,t.mmin,t.mmax),t.hasZ&&e.setInterval(y,0,t.zmin,t.zmax),t.setCacheValue(g,e)}return t.getCacheValue(g)}function E(t){if(!t.getCacheValue(g)){const e=new o.M,s=new i.P,r=t.points,n=t.hasM,a=t.hasZ,l=a?3:2;for(let t=0,i=r.length;t<i;t++){const i=r[t];s.setXYCoords(i[0],i[1]),a&&s.setZ(i[2]??0),n&&s.setM(i[l]??NaN),e.add(s)}t.setCacheValue(g,e)}return t.getCacheValue(g)}function v(t){if(!t.getCacheValue(g)){const e=new i.P;e.setXYCoords(t.x,t.y),t.hasM&&e.setM(t.m),t.hasZ&&e.setZ(t.z),t.setCacheValue(g,e)}return t.getCacheValue(g)}function T(t){if(!t.getCacheValue(g)){const{curveRings:e,hasM:s,hasZ:r,rings:n}=t,i=(0,p.fromGeometryToGXGeometry)({curveRings:e,hasM:s,hasZ:r,rings:n});t.setCacheValue(g,i)}return t.getCacheValue(g)}function A(t){if(!t.getCacheValue(g)){const{curvePaths:e,hasM:s,hasZ:r,paths:n}=t,i=(0,p.fromGeometryToGXGeometry)({curvePaths:e,hasM:s,hasZ:r,paths:n});t.setCacheValue(g,i)}return t.getCacheValue(g)}function C(t){if(t.wkid)return(0,a.c)(t.wkid);const e=t.wkt2||t.wkt;return e?(0,a.b)(e):null}function P(t,e){if(t)switch(t.getGeometryType()){case n.G.enumPoint:return G(t,e);case n.G.enumEnvelope:return w(t,e);case n.G.enumMultiPoint:return S(t,e);case n.G.enumPolyline:return b(t,e);case n.G.enumPolygon:return N(t,e)}return null}function w(t,e){if(t.isEmpty())return null;const s=new l.default({xmin:t.getXMin(),ymin:t.getYMin(),xmax:t.getXMax(),ymax:t.getYMax(),spatialReference:e}),r=t.getDescription();if(r.hasM()){const e=t.queryInterval(_,0);s.mmin=e.vmin,s.mmax=e.vmax}if(r.hasZ()){const e=t.queryInterval(y,0);s.zmin=e.vmin,s.zmax=e.vmax}return s.setCacheValue(g,t),s}function S(t,e){if(t.isEmpty())return null;const s=t.getDescription(),r=s.hasM(),n=s.hasZ(),o=[],a=new i.P;for(let i=0,u=t.getPointCount();i<u;i++){t.getPointByVal(i,a);const e=[a.getX(),a.getY()];n&&e.push(a.getZ()),r&&e.push(a.getM()),o.push(e)}const l=new u.default({hasM:r,hasZ:n,points:o,spatialReference:e});return l.setCacheValue(g,t),l}function G(t,e){if(t instanceof r.P)return new m.default({x:t.x,y:t.y,spatialReference:e});if(t.isEmpty())return null;const s=new m.default({x:t.getX(),y:t.getY(),spatialReference:e}),n=t.getDescription();return n.hasM()&&(s.m=t.getM()),n.hasZ()&&(s.z=t.getZ()),s.setCacheValue(g,t),s}function N(t,e){if(t.isEmpty())return null;const s=c.default.fromJSON({spatialReference:e,...(0,p.toGeometry)(t,null)});return s.setCacheValue(g,t),s}function b(t,e){if(t.isEmpty())return null;const s=h.default.fromJSON({spatialReference:e,...(0,p.toGeometry)(t,null)});return s.setCacheValue(g,t),s}},20240:(t,e,s)=>{s.d(e,{O:()=>u});var r=s(22290),n=s(65889),i=s(9270),o=s(45204),a=s(12834),l=s(75646);class u{getOperatorType(){return 10700}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}executeMany(t,e,s){return new m(t,e,s,arguments.length>3&&void 0!==arguments[3]?arguments[3]:1)}}class m extends r.G{constructor(t,e,s,r){super(),this.m_progressTracker=s,this.m_inputGeoms=t,this.m_spatialReference=e,this.m_currentGeometry=null,this.m_singlePartIndex=-1,this.m_singlePartCount=-1,this.m_polygonStart=-1,this.m_index=-1,this.m_options=r}tock(){return!0}getRank(){return 1}next(){if(this.m_singlePartIndex===this.m_singlePartCount){const t=this.m_inputGeoms.next();if(null===t)return null;if((0,i.d)(t),t.getGeometryType()===i.G.enumPolygon)if(1===this.m_options)this.m_currentGeometry=(new l.g).execute(t,this.m_spatialReference,!1,this.m_progressTracker);else if(2===this.m_options)if(t.getPathCount()<2)this.m_currentGeometry=t;else{const e=[0],s=t.getImpl().getIsSimple(0,e);if((0,a.i)(s))this.m_currentGeometry=t;else{const e=new n.E,s=e.addGeometry(t);let r=null;if(e.hasCurves()){r=new l.C;const s=new o.Envelope2D;t.queryEnvelope(s);const n=(0,a.b)(null,t,!0),i=(0,l.k)(n.total(),s);(0,l.n)(e,i,n.total(),12e3,null,r,null,this.m_progressTracker)}const u=e.createPathUserIndex();{let t=0;for(let r=e.getFirstPath(s);r!==n.n;r=e.getNextPath(r))e.setPathUserIndex(r,u,t++)}const m=(0,l.o)(e,s,this.m_progressTracker);(0,i.g)(m>=0);const c=[];for(let t=e.getFirstPath(s);t!==n.n;t=e.getNextPath(t))c.push(t);c.sort(((t,s)=>Math.abs(e.getPathUserIndex(t,m))-Math.abs(e.getPathUserIndex(s,m))));const h=t,p=new n.a({vd:t.getDescription()});p.reserveParts(h.getPointCount(),h.getPathCount());for(let t=0,n=c.length;t<n;t++){const s=c[t],r=e.getPathUserIndex(s,u),n=h.calculateRingArea2D(r)>0,i=e.getPathUserIndex(s,m)>=0;p.addPath(h,r,n===i)}this.m_currentGeometry=p}}else(0,i.t)("");else this.m_currentGeometry=t;this.m_singlePartCount=function(t){return t.isEmpty()?1:(0,l.q)(t)}(this.m_currentGeometry),this.m_singlePartIndex=0,this.m_polygonStart=0,this.m_index=this.m_inputGeoms.getGeometryID()}const t=this.getSingleGeometry(this.m_singlePartIndex,this.m_singlePartCount,this.m_polygonStart,this.m_currentGeometry);return t.getGeometryType()===i.G.enumPolygon&&(this.m_polygonStart+=t.getPathCount()),this.m_singlePartIndex++,t}getGeometryID(){return this.m_index}getSingleGeometry(t,e,s,r){let n=null;switch(r.getGeometryType()){case i.G.enumMultiPoint:n=new a.P({vd:r.getDescription()}),r.isEmpty()||r.getPointByVal(t,n);break;case i.G.enumPolyline:if(1===e)n=r;else{n=r.createInstance(),n.getImpl().addPath(r.getImpl(),t,!0);const e=[0],s=r.getImpl().getIsSimple(0,e);n.getImpl().setIsSimple(s,e[0],!0)}break;case i.G.enumPolygon:if(1===e)n=r;else{n=r.createInstance();const t=n.getImpl(),e=r.getImpl(),i=e.getPathFlagsStreamRef();let o=s;const a=e.getPathCount();do{t.addPath(e,o,!0),o++}while(o<a&&!(8&i.read(o)));t.getPathFlagsStreamRef().setBits(0,8);const l=[0],u=e.getIsSimple(0,l);t.setIsSimple(u,l[0],!0)}break;default:n=r}return n}}},22290:(t,e,s)=>{s.d(e,{G:()=>r,O:()=>n,S:()=>i});class r{*[Symbol.iterator](){let t=this.next();for(;t;)yield t,t=this.next()}}class n extends r{}class i extends r{constructor(t){super(),this.m_iGeom=-1,this.m_aGeoms=t?t.slice():[]}next(){if(this.m_iGeom<this.m_aGeoms.length-1){const t=this.m_aGeoms[++this.m_iGeom];return this.m_aGeoms[this.m_iGeom]=null,t}return null}tock(){return!1}getGeometryID(){return this.m_iGeom}getRank(){return 1}}},70924:(t,e,s)=>{s.d(e,{O:()=>m});var r=s(22290),n=s(9270),i=s(65889),o=s(12834),a=s(75646),l=a.C;function u(t,e){return{m_geometry:t,m_side:e}}class m{getOperatorType(){return 10005}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}execute(t,e,s,r,n){return new c(t,e,s,r,n)}}class c extends r.G{constructor(t,e,s,r,n){super(),this.m_cutIndex=-1,this.m_cuts=[],this.m_progressTracker=n,this.m_cuttee=e.clone(),this.m_cutter=new i.P({copy:s}),this.m_bConsiderTouch=t;const a=(0,o.g)(e,s);this.m_tolerance=(0,o.a)(r,a,!0)}next(){return-1===this.m_cutIndex&&this.generateCuts(),++this.m_cutIndex<this.m_cuts.length?this.m_cuts[this.m_cutIndex]:null}getGeometryID(){return this.m_cutIndex}tock(){return!0}getRank(){return 1}generateCuts(){switch(this.m_cuttee.getGeometryType()){case n.G.enumPolyline:this.generatePolylineCuts();break;case n.G.enumPolygon:this.generatePolygonCuts()}}generatePolylineCuts(){const t=new i.P,e=new i.P,s=new i.P;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];!function(t,e,s,r,n,o){if(e.isEmpty()){const t=u(e,0);return void n.push(t)}if(s.isEmpty()){const t=u(e,0);return void n.push(t)}const m=[],c=new i.E;{const i=c.createGeometryUserIndex(),h=c.addGeometry(e),p=c.addGeometry(s),g=new a.T(o);let _=0,y=null;if(c.hasCurves()){y=new l;const t=c.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(c,e,r.total(),12e3,y,null,o)}c.dbgVerifyCurves(),g.setEditShapeCrackAndCluster(c,r),g.cut(t,i,h,p,m);for(const t of m){null!==y&&y.stitchCurves(c,t,_,!1);const e=u(c.getGeometry(t),(0,a.m)(c.getGeometryUserIndex(t,i)));n.push(e)}null!==y&&y.clearStitcher(c)}}(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];1===o.m_side?t.add(o.m_geometry,!1):2===o.m_side||4===o.m_side?e.add(o.m_geometry,!1):3===o.m_side?this.m_cuts.push(o.m_geometry):0===o.m_side?s.add(o.m_geometry,!1):(0,n.c)("")}s.isEmpty()||t.isEmpty()&&e.isEmpty()&&!(this.m_cuts.length>=3)||this.m_cuts.push(s),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}generatePolygonCuts(){const t=new i.a,e=new i.a,s=new i.a;this.m_cuts.length=0,this.m_cuts.push(t),this.m_cuts.push(e);const r=[];!function(t,e,s,r,n,o){if(e.isEmpty()){const t=u(e,0);return void n.push(t)}if(s.isEmpty()){const t=u(e,0);return void n.push(t)}const m=[],c=new i.E;{const t=c.createGeometryUserIndex(),h=c.addGeometry(e),p=c.addGeometry(s),g=new a.T(o);let _=0,y=null;if(c.hasCurves()){y=new l;const t=c.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(c,e,r.total(),12e3,y,null,o)}c.dbgVerifyCurves(),g.setEditShapeCrackAndCluster(c,r),g.cut(!1,t,h,p,m),null!==y&&y.stitchCurves(c,i.n,_,!0);let f=c.getGeometry(h);const d=new i.a,x=new i.a,E=[];for(let e=0;e<m.length;e++){let s=null;{const n=new i.E,l=n.addGeometry(f),u=n.addGeometry(c.getGeometry(m[e]));if(n.hasCurves()){const t=n.getEnvelope2D(o);_=(0,a.s)(r.total());const e=(0,a.k)(r.total(),t);(0,a.l)(n,e,r.total(),12e3,y,null,o)}g.setEditShapeCrackAndCluster(n,r);const h=g.intersection(l,u);if(null!==y&&y.stitchCurves(n,i.n,_,!0),s=n.getGeometry(h),s.isEmpty())continue;const p=c.getGeometryUserIndex(m[e],t);2===p?d.add(s,!1):1===p?x.add(s,!1):E.push(s)}{const t=new i.E,s=t.addGeometry(f),n=t.addGeometry(c.getGeometry(m[e]));if(t.hasCurves()){const e=t.getEnvelope2D(o);_=(0,a.s)(r.total());const s=(0,a.k)(r.total(),e);(0,a.l)(t,s,r.total(),12e3,y,null,o)}g.setEditShapeCrackAndCluster(t,r);const l=g.difference(s,n);null!==y&&y.stitchCurves(t,i.n,_,!0),f=t.getGeometry(l)}}if(!f.isEmpty()&&m.length>0&&E.push(f),d.isEmpty()&&x.isEmpty())return;if(!d.isEmpty()){const t=u(d,1);n.push(t)}if(!x.isEmpty()){const t=u(x,2);n.push(t)}for(let e=0,s=E.length;e<s;++e){const t=u(E[e],3);n.push(t)}}}(this.m_bConsiderTouch,this.m_cuttee,this.m_cutter,this.m_tolerance,r,this.m_progressTracker);for(let i=0;i<r.length;i++){const o=r[i];1===o.m_side?t.add(o.m_geometry,!1):2===o.m_side?e.add(o.m_geometry,!1):3===o.m_side?this.m_cuts.push(o.m_geometry):0===o.m_side?s.add(o.m_geometry,!1):(0,n.c)("")}(0,n.g)(s.isEmpty()||1===r.length),t.isEmpty()&&e.isEmpty()&&this.m_cuts.length<3&&(this.m_cuts.length=0)}}},98891:(t,e,s)=>{s.r(e),s.d(e,{findSlicesByArea:()=>H,recursiveSliceEqualArea:()=>R,sliceIntoStrips:()=>M,supportsCurves:()=>V});var r=s(84190),n=s(22290),i=s(9270),o=s(45204),a=s(61853),l=s(65889),u=s(54256),m=s(12834),c=s(95188),h=s(20240),p=s(70924);function g(t,e,s,r,n){return new N(n).findSlicesByArea(t,e,s,r)}function _(t,e,s,r,n){return new N(n).sliceIntoStrips(t,e,s,r)}function y(t,e,s,r){return new N(r).recursiveSliceEqualArea(t,e,s)}function f(t){this.currentX=this.calcX(t)}function d(t){if(null===this.curve){const e=(t-this.y0)/(this.y1-this.y0);return(0,u.q)(this.x0,this.x1,e)}return this.curve.intersectionOfYMonotonicWithAxisX(t,this.x0)}function x(){return{x0:Number.NaN,y0:Number.NaN,x1:Number.NaN,y1:Number.NaN,currentX:Number.NaN,nextAET:null,prevAET:null,startNodeNext:null,nextInChain:null,curve:null,advance:f,calcX:d}}function E(t,e){const s=x();return s.x0=t.getStartX(),s.y0=t.getStartY(),s.x1=t.getEndX(),s.y1=t.getEndY(),e&&(s.y0=(0,u.b)(s.x0,s.x0=s.y0),s.y1=(0,u.b)(s.x1,s.x1=s.y1)),s.y1<s.y0&&(s.y1=(0,u.b)(s.y0,s.y0=s.y1),s.x1=(0,u.b)(s.x0,s.x0=s.x1)),s.currentX=Number.NaN,s.nextAET=null,s.prevAET=null,s.startNodeNext=null,s.nextInChain=null,s.curve=null,s}function v(t){const e=x();return e.x0=t.getStartX(),e.y0=t.getStartY(),e.x1=t.getEndX(),e.y1=t.getEndY(),e.curve=t,e.y1<e.y0&&(e.y1=(0,u.b)(e.y0,e.y0=e.y1),e.x1=(0,u.b)(e.x0,e.x0=e.x1)),e.currentX=Number.NaN,e.nextAET=null,e.prevAET=null,e.startNodeNext=null,e.nextInChain=null,e}function T(t){if(this.x===t.x&&this.y===t.y){const e=null!==this.endEdge,s=null!==t.startEdge;return e&&s?-1:1}return this.y!==t.y?this.y-t.y:this.x-t.x}function A(){return{x:Number.NaN,y:Number.NaN,startEdge:null,endEdge:null,compare:T}}function C(t,e){return{y:t,startingEdges:e}}class P{constructor(t,e,s,r,n,i){this.m_parent=t,this.m_y0=e,this.m_y1=s,this.m_t0=r,this.m_area=i}getMaxDerivative(){return 1}getValue(t,e){return 1===t?0:this.getArea(e)-this.m_area}getError(t){return(0,i.g)(0),0}getArea(t){const e=.5*(this.m_parent.m_sumBase-this.m_parent.m_sumA),s=this.m_y1-this.m_y0;let r=(this.m_parent.m_sumBase-e*(t+this.m_t0))*s*(t-this.m_t0),n=!1;for(let i=this.m_parent.m_AETHead;null!==i;i=i.nextAET)if(n=!n,n&&(null!==i.curve||null!==i.nextAET.curve)){const e=this.m_y0+s*this.m_t0,n=this.m_y0+s*t;i.curve&&(r+=S(i.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),i.nextAET.curve&&(r-=S(i.nextAET.curve,this.m_y0+s*this.m_t0,this.m_y0+s*t)),r+=(n-e)*(i.nextAET.calcX(e)-i.calcX(e)+(i.nextAET.calcX(n)-i.calcX(n)))*.5}return r}}function w(t,e,s){return{polygon:t,from:e,to:s}}function S(t,e,s){const r=[0,0],n=t.intersectionWithAxis2D(!0,e,null,r);(0,i.g)(1===n);const o=r[0],a=t.intersectionWithAxis2D(!0,s,null,r);(0,i.g)(1===a);const m=r[0],c=(0,u.m)(u.P,4);(0,l.w)(t,c,!0);const h=c[3],p=c[2],g=c[1],_=t.getCoordX(o)-t.getStartX(),y=t.getCoordY(o)-t.getStartY(),f=t=>{const e=t*t;return e*t*(10*(p.x*g.y-p.y*g.x)-15*t*(h.y*g.x-h.x*g.y)+6*e*(p.y*h.x-h.y*p.x))/60},d=t=>(-t*(g.y+t*(p.y+h.y*t))*_+t*(g.x+t*(p.x+h.x*t))*y)/2;return f(m)-f(o)-(d(m)-d(o))}class G extends n.G{constructor(t){super(),this.m_geoms=[],this.m_index=-1,this.m_id=-1,this.m_geoms=t}tock(){return!0}getRank(){return 1}next(){return this.m_index++,this.m_index>=this.m_geoms.length?null:(this.m_id=this.m_geoms[this.m_index].second,this.m_geoms[this.m_index].first)}getGeometryID(){return this.m_id}}class N{constructor(t){this.m_edges=[],this.m_curves=[],this.m_sortedNodes=[],this.m_sortHelper=[],this.m_cuts=[],this.m_cutAreas=[],this.m_totalAreaOfTraps=new u.K(0),this.m_areaTracking=0,this.m_splitArea=0,this.m_sumBase=0,this.m_sumA=0,this.m_numberOfCuts=0,this.m_currentScan=0,this.m_progressCounter=0,this.m_AETHead=null,this.m_bHorizontalSweep=!1,this.m_bPolygonHasCurves=!1,this.m_progressTracker=t}findSlicesByArea(t,e,s,r){r<0&&(0,i.t)("remainingArea");let n=t,o=null;n.hasNonLinearSegments()&&(this.m_bPolygonHasCurves=!0,o=(0,l.p)(t,1e-16,!0),function(t){t.getImpl().ensureXYMonotoneSegments()}(o),n=o);const a=Math.abs(n.calculateArea2D());return 0===a||0===s||r>=a||1===s&&0===r?[]:(this.m_splitArea=(a-r)/s,this.m_numberOfCuts=s-1,r>0&&this.m_numberOfCuts++,this.m_edges.length=0,this.m_sortedNodes.length=0,this.m_cuts.length=0,this.m_areaTracking=0,this.m_totalAreaOfTraps.reset(),this.m_curves.length=0,this.buildEdges(n),this.buildScanNodes(),this.trapezoidation(),this.m_cuts)}sliceIntoStrips(t,e,s,r){if(0===r)return new n.S([t]);const i=new o.Envelope2D;t.queryLooseEnvelope(i);const a=i.width()+i.height();return new G(this.splitPolygon(t,e,i.xmin-a-1+1,i.xmax+a+1,s,r))}recursiveSliceEqualArea(t,e,s){if(s<=1||t.isEmpty())return new n.S([t]);{const r=[],n=[];n.push((0,u.n)(t.clone(),s));let l=0,m=0;for(;n.length>0;){(0,i.g)(m++<2*s);const t=n.at(-1);if(n.pop(),1===t.second){r.push((0,u.n)(t.first,l++));continue}const c=new o.Envelope2D;t.first.queryEnvelope(c);const h=c.width()+c.height(),p=new a.T;p.setIdentity(),c.width()>c.height()&&(p.setRotateCcw90(),t.first.applyTransformation(p),p.transformEnvInPlace(c));const g=t.first.calculateArea2D(),_=g/t.second,y=g-Math.trunc(t.second/2)*_,f=new N(this.m_progressTracker).findSlicesByArea(t.first,e,1,y),d=new N(this.m_progressTracker).splitPolygon(t.first,e,c.xmin-h-1+1,c.xmax+h+1,f,1),x=d.length;if((0,i.g)(x>0&&x<=2),!p.isIdentity()){const t=new a.T;t.setRotateCw90(),d[0].first.applyTransformation(t),2===x&&d[1].first.applyTransformation(t)}2===x?(n.push((0,u.n)(d[1].first,t.second-Math.trunc(t.second/2))),n.push((0,u.n)(d[0].first,Math.trunc(t.second/2)))):n.push((0,u.n)(d[0].first,t.second))}return new G(r)}}recursiveSliceEqualAreaImpl(t,e,s,r){return(0,i.g)(0),{}}processTraps(t,e,s){s?this.processTrapsCurves(t,e):this.processTrapsLinear(t,e)}processTrapsLinear(t,e){let s=0,r=1;const n=.5*(this.m_sumBase-this.m_sumA),i=e-t,o=(this.m_sumBase-n*(r+s))*i*(r-s);if(o+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(o),void(this.m_areaTracking+=o);const a=new u.K(o),m=new u.E(0,1);let c=!1;for(;s<1;){const e=this.m_splitArea-this.m_areaTracking,u=[Number.NaN,Number.NaN];if(!((0,l.q)(-n*i,this.m_sumBase*i,(n*s-this.m_sumBase)*i*s-e,m,!1,u)>0)){c?this.m_areaTracking=a.getResult():this.m_areaTracking+=o;break}{c=!0,r=u[0],this.m_areaTracking=0,s=r,a.me(e);const n=r*i+t;if(this.m_cuts.push(n),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+o-a.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(o-a.getResult())}}this.m_totalAreaOfTraps.pe(o)}processTrapsCurves(t,e){let s=0,r=1;const n=new P(this,t,e,0,1,0).getArea(1);if(n+this.m_areaTracking<this.m_splitArea)return this.m_totalAreaOfTraps.pe(n),void(this.m_areaTracking+=n);const i=e-t,o=new u.K(n);let a=!1;for(;s<1;){const m=this.m_splitArea-this.m_areaTracking,c=new P(this,t,e,s,1,m),h=[0],p=new u.E(s,1);if(!((0,l.t)(c,p,1,h)>0)){a?this.m_areaTracking=o.getResult():this.m_areaTracking+=n;break}{a=!0,r=h[0],this.m_areaTracking=0,s=r,o.me(m);const e=r*i+t;if(this.m_cuts.push(e),this.m_cutAreas.push(this.m_totalAreaOfTraps.getResult()+n-o.getResult()),this.m_cuts.length===this.m_numberOfCuts)return void this.m_totalAreaOfTraps.pe(n-o.getResult())}}this.m_totalAreaOfTraps.pe(n)}advanceAET(){const t=this.m_sortedNodes[this.m_currentScan-1].y,e=this.m_sortedNodes[this.m_currentScan];let s=!1,r=!1;const n=new u.K(0);for(let a=this.m_AETHead;null!==a;a=a.nextAET){const t=a.prevAET;s=!s,null!==a.nextAET&&s&&(this.m_bPolygonHasCurves&&(a.curve||a.nextAET.curve)||n.pe(a.nextAET.currentX-a.currentX)),a.advance(e.y),null!==t&&a.currentX<t.currentX&&(r=!0)}this.m_sumBase=n.getResult(),r&&this.sortAET();const i=new u.K(0);s=!1;let o=!1;for(let a=this.m_AETHead;null!==a;a=a.nextAET)o=o||null!==a.curve,s=!s,null!==a.prevAET&&(s||this.m_bPolygonHasCurves&&(a.curve||a.prevAET.curve)||i.pe(a.currentX-a.prevAET.currentX));this.m_sumA=i.getResult(),this.processTraps(t,e.y,o);for(let a=this.m_AETHead;null!=a;){const t=a.prevAET,s=a.nextAET;if(e.y===a.y1)if(a.prevAET=null,a.nextAET=null,null!==a.nextInChain){const e=a.currentX;a=a.nextInChain,a.currentX=e,a.prevAET=t,t?t.nextAET=a:this.m_AETHead=a,a.nextAET=s,s&&(s.prevAET=a)}else t?t.nextAET=s:this.m_AETHead=s,s&&(s.prevAET=t);a=s}}mergeNewEdgesToAET(){for(let r=this.m_sortedNodes[this.m_currentScan].startingEdges;null!==r;r=r.startNodeNext)Number.isNaN(r.currentX)&&(this.m_sortHelper.push(r),r.currentX=r.x0);if(!this.m_sortHelper.length)return;this.sortHelper();let t=this.m_AETHead,e=0,s=t;for(;null!==t&&e<this.m_sortHelper.length;)t.currentX>this.m_sortHelper[e].currentX?(this.m_sortHelper[e].prevAET=t.prevAET,t.prevAET?t.prevAET.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=t,t.prevAET=this.m_sortHelper[e],e++):(s=t,t=t.nextAET);for(;e<this.m_sortHelper.length;)this.m_sortHelper[e].prevAET=s,null!==s?s.nextAET=this.m_sortHelper[e]:this.m_AETHead=this.m_sortHelper[e],this.m_sortHelper[e].nextAET=null,s=this.m_sortHelper[e],e++;this.m_sortHelper.length=0}sortAET(){for(let e=this.m_AETHead;null!==e;e=e.nextAET)this.m_sortHelper.push(e);this.sortHelper(),this.m_AETHead=null;let t=null;for(const e of this.m_sortHelper)e.prevAET=t,t?t.nextAET=e:this.m_AETHead=e,e.nextAET=null,t=e;this.m_sortHelper.length=0}sortHelper(){this.m_sortHelper.sort(((t,e)=>t.currentX-e.currentX))}trapezoidation(){for(this.m_currentScan=0,this.mergeNewEdgesToAET(),this.m_currentScan++;this.m_currentScan<this.m_sortedNodes.length&&(this.progress(),this.advanceAET(),this.m_cuts.length!==this.m_numberOfCuts);)this.mergeNewEdgesToAET(),this.m_currentScan++}buildEdges(t){const e=t.querySegmentIterator();for(e.stripAttributes();e.nextPath();)for(;e.hasNextSegment();){const t=e.nextSegment();if(t.isCurve()){const e=t;if((0,l.u)(e),this.m_bHorizontalSweep){const t=(0,u.m)(u.P,4);e.queryControlPoints(t);for(const e of t)e.y=(0,u.b)(e.x,e.x=e.y);e.constructPoints(t)}const s=e.getStartY(),r=e.getEndY();if(r===s)continue;r<s&&e.reverse(),this.m_curves.push(e.clone()),this.m_edges.push(v(this.m_curves.at(-1)))}else{const e=this.m_bHorizontalSweep?t.getStartX():t.getStartY();if((this.m_bHorizontalSweep?t.getEndX():t.getEndY())===e)continue;this.m_edges.push(E(t,this.m_bHorizontalSweep))}}this.m_edges.sort(((t,e)=>t.y0===e.y0?t.x0-e.x0:t.y0-e.y0))}buildScanNodes(){const t=[];for(const n of this.m_edges){const e=A();e.x=n.x0,e.y=n.y0,e.startEdge=n,e.endEdge=null,t.push(e);const s=A();s.x=n.x1,s.y=n.y1,s.startEdge=null,s.endEdge=n,t.push(s)}t.sort(((t,e)=>t.compare(e)));let e=0,s=t[e].y;this.m_sortedNodes.push(C(s,t[e].startEdge));let r=e;for(e++;e!==t.length;++e){t[e].y!==s&&(this.m_sortedNodes.push(C(t[e].y,null)),s=t[e].y);const n=t[e].startEdge;if(n){const t=this.m_sortedNodes.at(-1);n.startNodeNext=t.startingEdges,t.startingEdges=n}if(t[r].x!==t[e].x||t[r].y!==t[e].y){if(e-r==2){let e=r;e++,null!==t[r].endEdge&&null!==t[e].startEdge&&(t[r].endEdge.nextInChain=t[e].startEdge)}r=e}}}progress(){}splitPolygonLinear(t,e,s,r,a,m){const c=[];c.push([t,0,m]);const g=[],_=new l.P;for(_.startPathCoords(s,0),_.lineToCoords(r,0);c.length>0;){const l=c.at(-1);c.pop();const y=l[0],f=l[1],d=l[2],x=(new h.O).executeMany(new n.S([y]),e,this.m_progressTracker);for(let n=x.next();null!==n;n=x.next()){const l=n,h=new o.Envelope2D;l.queryLooseEnvelope(h);let y=f,x=d;for(let t=f,e=d-1;t<d;++t,--e)h.ymin>=a[t]&&(y=t+1),h.ymax<=a[e]&&(x=e);if(y!==d)if(x!==f)if(y!==x)if(this.isYMonotone(l))this.splitYMonotone(g,l,e,a,y,x);else{const n=Math.trunc((y+x)/2);_.setXYCoords(0,s,a[n]),_.setXYCoords(1,r,a[n]);const f=(new p.O).execute(!1,l,_,null,this.m_progressTracker),d=f.next(),E=f.next(),v=f.next();if(null!==d){if(d.isEmpty()||(n===x-1?(g.push((0,u.n)(d,n)),(0,i.g)(b(g.at(-1).first,e,t,g.at(-1).second,a,m))):c.push([d,n+1,x])),E.isEmpty()||(n===y?(g.push((0,u.n)(E,n-1)),(0,i.g)(b(g.at(-1).first,e,t,g.at(-1).second,a,m))):c.push([E,y,n])),null!==v&&!v.isEmpty()){const t=new o.Envelope2D;v.queryLooseEnvelope(t),t.ymin>=a[n]?c.push([v,n+1,x]):t.ymax<=a[n]?c.push([v,y,n]):c.push([v,y,x])}}else n+1===x?(a[n]-h.ymin<h.ymax-a[n]?g.push((0,u.n)(l,n)):g.push((0,u.n)(l,n+1)),(0,i.g)(b(g.at(-1).first,e,t,g.at(-1).second,a,m))):c.push([l,n+1,x])}else g.push((0,u.n)(n,y-1));else g.push((0,u.n)(n,f-1));else g.push((0,u.n)(n,d-1))}}return g}splitPolygon(t,e,s,r,n,i){const a=new o.Envelope2D;t.queryLooseEnvelope(a),a.inflateCoords(0,Math.max(a.width(),a.height()));const m=[],h=[];for(h.push(w(t,0,i));h.length;){const i={...h.at(-1)};if(h.pop(),i.polygon.hasNonLinearSegments()){const t=Math.trunc((i.to+i.from)/2),l=n[t],p=new o.Envelope2D(s,a.ymin,r,l),g=(new c.O).execute(i.polygon,p,e,this.m_progressTracker);g.isEmpty()||(t-i.from==0?m.push((0,u.n)(g,t-1)):h.push(w(g,i.from,t)));const _=new o.Envelope2D(s,l,r,a.ymax),y=(new c.O).execute(i.polygon,_,e,this.m_progressTracker);y.isEmpty()||(i.to-t==1?m.push((0,u.n)(y,t)):h.push(w(y,t+1,i.to)))}else{const o=this.splitPolygonLinear(t,e,s,r,n.slice(i.from),i.to-i.from);m.push(...o)}}m.sort(((t,e)=>t.second-e.second));const p=[];return(0,l.v)(m,((t,e)=>t.second===e.second),((t,e)=>{const s=new l.a;for(let r=t;r!==e;++r)s.add(m[r].first,!1);p.push((0,u.n)(s,m[t].second))})),p}isYMonotone(t){if(1!==t.getPathCount())return!1;const e=t.getXY(0);let s=0,r=0;const n=new u.P;for(let i=1,o=t.getPointCount();i<=o;i++){t.queryXY(i===o?0:i,n);const a=n.y>e.y?1:n.y<e.y?-1:0;if(e.setCoordsPoint2D(n),s!==a&&0!==a){if(0!==s&&(r++,r>2))return!1;s=a}}return!0}splitYMonotone(t,e,s,r,n,o){const a=new l.E;a.addGeometry(e);const m=a.getFirstPath(a.getFirstGeometry()),c=a.getFirstVertex(m),h=new u.P,p=new u.P;let g=c,_=c;{const t=a.getXY(c);h.setCoordsPoint2D(t),p.setCoordsPoint2D(t)}let y=a.getNextVertex(c);const f=new u.P;for(let i=0,l=a.getPathSize(m);i<l;i++,y=a.getNextVertex(y))a.queryXY(y,f),f.compare(h)<0?(g=y,h.setCoordsPoint2D(f)):f.compare(p)>0&&(_=y,p.setCoordsPoint2D(f));let d=g,x=g,E=d,v=x,T=!1,A=!1,C=n,P=h.y,w=h.y,S=!1;for(;C<o;)if(r[C]<=h.y)C++;else{if(r[C]>=p.y)break;if(!T){const t=a.getNextVertex(d),e=a.getY(t);if(e<P)break;const s=r[C];P<=s&&e>=s?T=!0:(P=e,d=t)}if(!A){const t=a.getPrevVertex(x),e=a.getY(t);if(e<w)break;const s=r[C];w<=s&&e>=s?A=!0:(w=e,x=t)}if(T&&A){S=!0;let e=a.getXY(d);const s=a.getNextVertex(d);let n=a.getXY(s),o=l.n;if(n.y===e.y)o=n.x<e.x?d:s;else{const t=(r[C]-e.y)/(n.y-e.y);if(0===t)o=d;else if(1===t)o=s;else{const e=a.splitSegmentAxisAware(d,[t],1,null,-1);(0,i.g)(1===e),o=a.getNextVertex(d),a.getY(o)!==r[C]&&a.setXYCoords(o,a.getX(o),r[C])}}const m=a.getPrevVertex(x);e=a.getXY(m),n=a.getXY(x);let c=l.n;if(n.y===e.y)c=n.x<e.x?x:m;else{const t=(r[C]-e.y)/(n.y-e.y);if(0===t)c=m;else if(1===t)c=x;else{const e=a.splitSegmentAxisAware(m,[t],1,null,-1);(0,i.g)(1===e),c=a.getNextVertex(m),a.getY(c)!==r[C]&&a.setXYCoords(c,a.getX(c),r[C])}}t.push((0,u.n)(this.extractTrapezoid(a,E,o,v,c),C-1)),E=o,v=c,d=o,x=c,P=w=r[C],T=!1,A=!1,C++}}S?t.push((0,u.n)(this.extractTrapezoid(a,E,_,v,_),C-1)):t.push((0,u.n)(e,C))}extractTrapezoid(t,e,s,r,n){const i=new l.a({vd:t.getVertexDescription()}),o=new m.P;let a=!0;for(let l=e;;l=t.getNextVertex(l)){const e=t.getSegment(l);if(e?i.addSegment(e,a):(t.queryPoint(l,o),a?i.startPathPoint(o):i.lineToPoint(o)),a=!1,l===s)break}s!==n&&(t.queryPoint(n,o),i.lineToPoint(o)),a=!0;for(let l=n;;l=t.getNextVertex(l)){const s=t.getSegment(l);if(s?i.addSegment(s,a):a||l===e||(t.queryPoint(l,o),i.lineToPoint(o)),a=!1,l===r)break}return i}}function b(t,e,s,r,n,i){const a=new o.Envelope2D;t.queryEnvelope(a);const l=4*(0,m.b)(e,s,!0).total();return(!(r>=0)||a.ymin+l>=n[r])&&!(r+1<i&&a.ymax>n[r+1]+l)}class k extends n.G{constructor(t,e,s,r,n,i,o){super(),this.m_resultCursor=null,this.m_method=t,this.m_polygon=e,this.m_sr=s,this.m_ySplits=r?.slice()??null,this.m_transform=n,this.m_bReversePaths=n?.isReflective()??!1,this.m_inverseTransform=n?n.clone().invertThis():null,this.m_partCount=i,this.m_tracker=o}tock(){return!0}getRank(){return 1}next(){this.m_resultCursor||(this.m_method?this.recursiveSliceEqualArea():this.sliceIntoStrips());const t=this.m_resultCursor.next();return t?(this.m_inverseTransform&&!this.m_inverseTransform.isIdentity()&&(t.applyTransformation(this.m_inverseTransform),this.m_bReversePaths&&t.reverseAllPaths()),t):t}getGeometryID(){return this.m_resultCursor?this.m_resultCursor.getGeometryID():-1}sliceIntoStrips(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=_(this.m_polygon,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=_(t,this.m_sr,this.m_ySplits,this.m_ySplits.length,this.m_tracker)}}recursiveSliceEqualArea(){if(!this.m_transform||this.m_transform.isIdentity())this.m_resultCursor=y(this.m_polygon,this.m_sr,this.m_partCount,this.m_tracker);else{const t=this.m_polygon.clone();t.applyTransformation(this.m_transform),this.m_bReversePaths&&t.reverseAllPaths(),this.m_resultCursor=y(t,this.m_sr,this.m_partCount,this.m_tracker)}}}const I=new class{getOperatorType(){return 10011}accelerateGeometry(t,e,s){return!1}canAccelerateGeometry(t){return!1}supportsCurves(){return!0}sliceIntoStrips(t,e,s,r,n,i){return new k(0,t,e,s,n,0,i)}findSlicesByArea(t,e,s,r,n,i){if(!n||n.isIdentity())return g(t,e,s,r,i);{const o=t.clone();return o.applyTransformation(n),g(o,e,s,r,i)}}recursiveSliceEqualArea(t,e,s,r,n){return new k(1,t,e,null,r,s,n)}};var X=s(2862);function H(t,e,s){let n=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{transform:i,unit:o}=n,a=(0,X.getSpatialReference)(t);if(s&&o){if(a.isGeographic)throw new Error("Unable to convert from an angular area unit to a linear area unit.");const t=(0,r.B5)(a);t!==o&&(t?s=(0,r.oU)(s,o,t):(s=(0,r.oU)(s,o,"square-meters"),s=Math.sqrt(s),s/=(0,r.GA)(a),s**=2))}return function(t,e,s,r,n){return I.findSlicesByArea(t,e,s,r,n,null)}((0,X.fromPolygon)(t),(0,X.fromSpatialReference)(a),e,s,i?.transform??null)}function R(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{transform:r}=s,n=(0,X.getSpatialReference)(t);return function(t,e,s,r){const n=I.recursiveSliceEqualArea(t,e,s,r,null);return Array.from(n)}((0,X.fromPolygon)(t),(0,X.fromSpatialReference)(n),e,r?.transform??null).map((t=>(0,X.toPolygon)(t,n)))}function M(t,e){let s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:{};const{transform:r}=s,n=(0,X.getSpatialReference)(t);return function(t,e,s,r){const n=I.sliceIntoStrips(t,e,s,0,r,null);return Array.from(n)}((0,X.fromPolygon)(t),(0,X.fromSpatialReference)(n),e,r?.transform??null).map((t=>(0,X.toPolygon)(t,n)))}const V=I.supportsCurves()}}]);