"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[60652],{60652:(e,n,t)=>{t.r(n),t.d(n,{buffer:()=>z,changeDefaultSpatialReferenceTolerance:()=>Y,clearDefaultSpatialReferenceTolerance:()=>Z,clip:()=>y,contains:()=>g,convexHull:()=>D,crosses:()=>h,cut:()=>w,densify:()=>W,difference:()=>k,disjoint:()=>A,distance:()=>m,equals:()=>S,extendedSpatialReferenceInfo:()=>d,flipHorizontal:()=>q,flipVertical:()=>B,generalize:()=>G,geodesicArea:()=>Q,geodesicBuffer:()=>C,geodesicDensify:()=>F,geodesicLength:()=>U,intersect:()=>T,intersectLinesToPoints:()=>X,intersects:()=>R,isSimple:()=>N,nearestCoordinate:()=>H,nearestVertex:()=>_,nearestVertices:()=>I,offset:()=>E,overlaps:()=>O,planarArea:()=>K,planarLength:()=>M,relate:()=>J,rotate:()=>j,simplify:()=>b,symmetricDifference:()=>L,touches:()=>v,union:()=>V,within:()=>x});var r=t(34037),a=t(75400),i=t(78629);function c(e){return Array.isArray(e)?e[0]?.spatialReference:e?.spatialReference}function o(e){return e?Array.isArray(e)?e.map(o):e.toJSON?e.toJSON():e:e}function u(e){return Array.isArray(e)?e.map((e=>(0,i.fromJSON)(e))):(0,i.fromJSON)(e)}let s;async function f(){return s||(s=(0,r.ho)("geometryEngineWorker",{strategy:"distributed"})),s}async function l(e,n){return(await f()).invoke("executeGEOperation",{operation:e,parameters:o(n)})}async function p(e,n){const t=await f();return Promise.all(t.broadcast("executeGEOperation",{operation:e,parameters:o(n)}))}function d(e){return l("extendedSpatialReferenceInfo",[e])}async function y(e,n){return u(await l("clip",[c(e),e,n]))}async function w(e,n){return u(await l("cut",[c(e),e,n]))}function g(e,n){return l("contains",[c(e),e,n])}function h(e,n){return l("crosses",[c(e),e,n])}function m(e,n,t){return l("distance",[c(e),e,n,t])}function S(e,n){return l("equals",[c(e),e,n])}function R(e,n){return l("intersects",[c(e),e,n])}function v(e,n){return l("touches",[c(e),e,n])}function x(e,n){return l("within",[c(e),e,n])}function A(e,n){return l("disjoint",[c(e),e,n])}function O(e,n){return l("overlaps",[c(e),e,n])}function J(e,n,t){return l("relate",[c(e),e,n,t])}function N(e){return l("isSimple",[c(e),e])}async function b(e){return u(await l("simplify",[c(e),e]))}async function D(e){let n=arguments.length>1&&void 0!==arguments[1]&&arguments[1];return u(await l("convexHull",[c(e),e,n]))}async function k(e,n){return u(await l("difference",[c(e),e,n]))}async function L(e,n){return u(await l("symmetricDifference",[c(e),e,n]))}async function T(e,n){return u(await l("intersect",[c(e),e,n]))}async function V(e){const n=function(e,n){let t;return Array.isArray(e)?t=e:(t=[],t.push(e),null!=n&&t.push(n)),t}(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return u(await l("union",[c(n),n]))}async function E(e,n,t,r,a,i){return u(await l("offset",[c(e),e,n,t,r,a,i]))}async function z(e,n,t){let r=arguments.length>3&&void 0!==arguments[3]&&arguments[3];const a=[c(e),e,n,t,r];return u(await l("buffer",a))}async function C(e,n,t,r,a,i){const o=[c(e),e,n,t,r,a,i];return u(await l("geodesicBuffer",o))}async function H(e,n){let t=!(arguments.length>2&&void 0!==arguments[2])||arguments[2];const r=await l("nearestCoordinate",[c(e),e,n,t]);return{...r,coordinate:a.default.fromJSON(r.coordinate)}}async function _(e,n){const t=await l("nearestVertex",[c(e),e,n]);return{...t,coordinate:a.default.fromJSON(t.coordinate)}}async function I(e,n,t,r){return(await l("nearestVertices",[c(e),e,n,t,r])).map((e=>({...e,coordinate:a.default.fromJSON(e.coordinate)})))}function P(e){return"xmin"in e?e.center:"x"in e?e:e.extent?.center}async function j(e,n,t){if(null==e)throw new $;const r=e.spatialReference;if(null==(t=t??P(e)))throw new $;const a=e.constructor.fromJSON(await l("rotate",[r,e,n,t]));return a.spatialReference=r,a}async function q(e,n){if(null==e)throw new $;const t=e.spatialReference;if(null==(n=n??P(e)))throw new $;const r=e.constructor.fromJSON(await l("flipHorizontal",[t,e,n]));return r.spatialReference=t,r}async function B(e,n){if(null==e)throw new $;const t=e.spatialReference;if(null==(n=n??P(e)))throw new $;const r=e.constructor.fromJSON(await l("flipVertical",[t,e,n]));return r.spatialReference=t,r}async function G(e,n,t,r){return u(await l("generalize",[c(e),e,n,t,r]))}async function W(e,n,t){return u(await l("densify",[c(e),e,n,t]))}async function F(e,n,t){let r=arguments.length>3&&void 0!==arguments[3]?arguments[3]:0;return u(await l("geodesicDensify",[c(e),e,n,t,r]))}function K(e,n){return l("planarArea",[c(e),e,n])}function M(e,n){return l("planarLength",[c(e),e,n])}function Q(e,n,t){return l("geodesicArea",[c(e),e,n,t])}function U(e,n,t){return l("geodesicLength",[c(e),e,n,t])}async function X(e,n){return u(await l("intersectLinesToPoints",[c(e),e,n]))}async function Y(e,n){await p("changeDefaultSpatialReferenceTolerance",[e,n])}async function Z(e){await p("clearDefaultSpatialReferenceTolerance",[e])}class $ extends Error{constructor(){super("Illegal Argument Exception")}}}}]);