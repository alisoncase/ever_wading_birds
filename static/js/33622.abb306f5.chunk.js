"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[9240,33622],{9240:(e,t,n)=>{n.d(t,{QueueProcessor:()=>c});var i=n(17741),r=n(49959),s=n(83626),a=n(90450),l=n(7187),o=n(20889);class u{constructor(e,t){this.item=e,this.controller=t,this.promise=null}}class c{constructor(e){this._schedule=null,this._deferreds=new a.A,this._controllers=new a.A,this._processingItems=new a.A,this._pausedSignal=(0,o.v)(!1),this.concurrency=1,e.concurrency&&(this.concurrency=e.concurrency),this._queue=new s.A(e.peeker),this.process=e.process}destroy(){this.clear(),this._schedule=(0,i.xt)(this._schedule)}get updating(){return this.running}get length(){return this._processingItems.size+this._queue.length}get running(){return!this._pausedSignal.value&&this._queue.length>0&&this._processingItems.size<this.concurrency}abort(e){const t=this._controllers.get(e);t&&t.abort()}clear(){this._queue.clear();const e=[];this._controllers.forEach((t=>e.push(t))),this._controllers.clear(),e.forEach((e=>e.abort())),this._processingItems.clear(),this._cancelNext()}forEach(e){this._deferreds.forEach(((t,n)=>e(n)))}get(e){const t=this._deferreds.get(e);return t?t.promise:void 0}isOngoing(e){return this._processingItems.has(e)}has(e){return this._deferreds.has(e)}pause(){this._pausedSignal.value||(this._pausedSignal.value=!0,this._cancelNext())}push(e,t){const n=this.get(e);if(n)return n;const i=new AbortController;let s=null;t&&(s=(0,r.onAbort)(t,(()=>i.abort())));const a=()=>{l.remove(),null!=s&&s.remove(),this._removeItem(e),this._queue.remove(e),this._scheduleNext()},l=(0,r.onAbortOrThrow)(i.signal,(()=>{const t=this._processingItems.get(e);t&&t.controller.abort(),a(),o.reject((0,r.createAbortError)())})),o=(0,r.createResolver)();return this._deferreds.set(e,o),this._controllers.set(e,i),o.promise.then(a,a),this._queue.push(e),this._scheduleNext(),o.promise}last(){return this._queue.last()}lastPromise(){const e=this.last();return e?this.get(e):null}peek(){return this._queue.peek()}popLast(){const e=this._queue.popLast();return e&&(this._deferreds.get(e)?.reject((0,r.createAbortError)()),this._removeItem(e)),e}reset(){const e=Array.from(this._processingItems.values());this._processingItems.clear();for(const t of e)this._queue.push(t.item),t.controller.abort();this._scheduleNext()}resume(){this._pausedSignal.value&&(this._pausedSignal.value=!1,this._scheduleNext())}takeAll(){const e=[];for(;this._queue.length;)e.push(this._queue.pop());return this.clear(),e}_removeItem(e){this._deferreds.delete(e),this._controllers.delete(e),this._processingItems.delete(e)}_scheduleNext(){this._pausedSignal.value||this._schedule||(this._schedule=(0,l.schedule)((()=>{this._schedule=null,this._next()})))}_next(){for(;this._queue.length>0&&this._processingItems.size<this.concurrency;)this._process(this._queue.pop())}_cancelNext(){this._schedule&&(this._schedule.remove(),this._schedule=null)}_processResult(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).resolve(t))}_processError(e,t){this._canProcessFulfillment(e)&&(this._scheduleNext(),this._deferreds.get(e.item).reject(t))}_canProcessFulfillment(e){return!!this._deferreds.get(e.item)&&this._processingItems.get(e.item)===e}_process(e){if(null==e)return;let t;const n=new AbortController,i=new u(e,n);this._processingItems.set(e,i);try{t=this.process(e,n.signal)}catch(s){this._processError(i,s)}(0,r.isPromiseLike)(t)?(i.promise=t,t.then((e=>this._processResult(i,e)),(e=>this._processError(i,e)))):this._processResult(i,t)}}},12305:(e,t,n)=>{n.d(t,{A:()=>d});var i=n(93800),r=n(42761),s=n(19455),a=n(48602),l=(n(21265),n(50925),n(14746),n(47332)),o=n(75269);const u=new r.J({esriClassifyEqualInterval:"equal-interval",esriClassifyManual:"manual",esriClassifyNaturalBreaks:"natural-breaks",esriClassifyQuantile:"quantile",esriClassifyStandardDeviation:"standard-deviation",esriClassifyDefinedInterval:"defined-interval"}),c=new r.J({esriNormalizeByLog:"log",esriNormalizeByPercentOfTotal:"percent-of-total",esriNormalizeByField:"field"});let h=class extends s.A{constructor(e){super(e),this.type="class-breaks-definition",this.breakCount=null,this.classificationField=null,this.classificationMethod=null,this.normalizationField=null,this.normalizationType=null}set standardDeviationInterval(e){"standard-deviation"===this.classificationMethod&&this._set("standardDeviationInterval",e)}set definedInterval(e){"defined-interval"===this.classificationMethod&&this._set("definedInterval",e)}};(0,i._)([(0,l.e)({classBreaksDef:"class-breaks-definition"})],h.prototype,"type",void 0),(0,i._)([(0,a.MZ)({json:{write:!0}})],h.prototype,"breakCount",void 0),(0,i._)([(0,a.MZ)({json:{write:!0}})],h.prototype,"classificationField",void 0),(0,i._)([(0,a.MZ)({type:String,json:{read:u.read,write:u.write}})],h.prototype,"classificationMethod",void 0),(0,i._)([(0,a.MZ)({json:{write:!0}})],h.prototype,"normalizationField",void 0),(0,i._)([(0,a.MZ)({json:{read:c.read,write:c.write}})],h.prototype,"normalizationType",void 0),(0,i._)([(0,a.MZ)({value:null,json:{write:!0}})],h.prototype,"standardDeviationInterval",null),(0,i._)([(0,a.MZ)({value:null,json:{write:!0}})],h.prototype,"definedInterval",null),h=(0,i._)([(0,o.$)("esri.rest.support.ClassBreaksDefinition")],h);const d=h},17661:(e,t,n)=>{n.d(t,{_:()=>a,t:()=>l});var i=n(50925);const r=()=>i.A.getLogger("esri.rest.support.generateRendererUtils");function s(e,t){return Number(e.toFixed(t))}function a(e){const t=c(e),n=[],i=t.uniqueValues.length;for(let r=0;r<i;r++){const e=t.uniqueValues[r],i=t.valueFrequency[r],s=e.toString();n.push({value:e,count:i,label:s})}return{uniqueValues:n}}function l(e,t){const{normalizationTotal:n}=e;return{classBreaks:o(e,t),normalizationTotal:n}}function o(e,t){const n=e.definition,{classificationMethod:i,normalizationType:r,definedInterval:a}=n,l=n.breakCount??1,o=[];let d=e.values;if(0===d.length)return[];d=d.sort(((e,t)=>e-t));const[f,m]=t??[d.at(0),d.at(-1)];if("equal-interval"===i)if(d.length>=l){const e=(m-f)/l;let t=f;for(let n=1;n<l;n++){const i=s(f+n*e,6);o.push({minValue:t,maxValue:i,label:u(t,i,r)}),t=i}o.push({minValue:t,maxValue:m,label:u(t,m,r)})}else d.forEach((e=>{o.push({minValue:e,maxValue:e,label:u(e,e,r)})}));else if("natural-breaks"===i){const t=c(d),n=e.valueFrequency||t.valueFrequency,i=h(t.uniqueValues,n,l);let a=f;for(let e=1;e<l;e++)if(t.uniqueValues.length>e){const n=s(t.uniqueValues[i[e]],6);o.push({minValue:a,maxValue:n,label:u(a,n,r)}),a=n}o.push({minValue:a,maxValue:m,label:u(a,m,r)})}else if("quantile"===i)if(d.length>=l&&f!==m){let e=f,t=Math.ceil(d.length/l),n=0;for(let i=1;i<l;i++){let s=t+n-1;s>d.length&&(s=d.length-1),s<0&&(s=0),o.push({minValue:e,maxValue:d[s],label:u(e,d[s],r)}),e=d[s],n+=t,t=Math.ceil((d.length-n)/(l-i))}o.push({minValue:e,maxValue:m,label:u(e,m,r)})}else{let e=-1;for(let t=0;t<d.length;t++){const n=d[t];n!==e&&(e=n,o.push({minValue:e,maxValue:n,label:u(e,n,r)}),e=n)}}else if("standard-deviation"===i){const e=function(e){let t=0;for(let n=0;n<e.length;n++)t+=e[n];return t/=e.length,t}(d),t=function(e,t){let n=0;for(let i=0;i<e.length;i++){const r=e[i];n+=(r-t)*(r-t)}return n/=e.length,Math.sqrt(n)}(d,e);if(0===t)o.push({minValue:d[0],maxValue:d[0],label:u(d[0],d[0],r)});else{const n=function(e,t,n,i,r){let s=Math.max(i-e,t-i)/r/n;return s=s>=1?1:s>=.5?.5:.25,s}(f,m,l,e,t)*t;let i=0,a=f;for(let t=l;t>=1;t--){const l=s(e-(t-.5)*n,6);o.push({minValue:a,maxValue:l,label:u(a,l,r)}),a=l,i++}let c=s(e+.5*n,6);o.push({minValue:a,maxValue:c,label:u(a,c,r)}),a=c,i++;for(let t=1;t<=l;t++)c=i===2*l?m:s(e+(t+.5)*n,6),o.push({minValue:a,maxValue:c,label:u(a,c,r)}),a=c,i++}}else if("defined-interval"===i){if(!a)return o;const[e,n]=t??[d.at(0),d.at(-1)],i=Math.ceil((n-e)/a);let l=e;for(let t=1;t<i;t++){const n=s(e+t*a,6);o.push({minValue:l,maxValue:n,label:u(l,n,r)}),l=n}o.push({minValue:l,maxValue:n,label:u(l,n,r)})}return o}function u(e,t,n){let i=null;return i=e===t?n&&"percent-of-total"===n?e+"%":e.toString():n&&"percent-of-total"===n?e+"% - "+t+"%":e+" - "+t,i}function c(e){const t=[],n=[];let i=Number.MIN_VALUE,r=1,s=-1;for(let a=0;a<e.length;a++){const l=e[a];l===i?(r++,n[s]=r):null!==l&&(t.push(l),i=l,r=1,n.push(r),s++)}return{uniqueValues:t,valueFrequency:n}}function h(e,t,n){const i=e.length,r=[];n>i&&(n=i);for(let a=0;a<n;a++)r.push(Math.round(a*i/n-1));r.push(i-1);let s=d(r,e,t,n);return function(e,t,n,i,r,s){let a=0,l=0,o=0,u=0,c=!0;for(let h=0;h<2&&c;h++){0===h&&(c=!1);for(let h=0;h<s-1;h++)for(;n[h+1]+1!==n[h+2];){n[h+1]=n[h+1]+1;const s=f(h,n,i,r);o=s.sbMean,a=s.sbSdcm;const d=f(h+1,n,i,r);if(u=d.sbMean,l=d.sbSdcm,!(a+l<t[h]+t[h+1])){n[h+1]=n[h+1]-1;break}t[h]=a,t[h+1]=l,e[h]=o,e[h+1]=u,c=!0}for(let h=s-1;h>0;h--)for(;n[h]!==n[h-1]+1;){n[h]=n[h]-1;const s=f(h-1,n,i,r);o=s.sbMean,a=s.sbSdcm;const d=f(h,n,i,r);if(u=d.sbMean,l=d.sbSdcm,!(a+l<t[h-1]+t[h])){n[h]=n[h]+1;break}t[h-1]=a,t[h]=l,e[h-1]=o,e[h]=u,c=!0}}return c}(s.mean,s.sdcm,r,e,t,n)&&(s=d(r,e,t,n)),r}function d(e,t,n,i){let r=[],s=[],a=[],l=0;const o=[],u=[];for(let m=0;m<i;m++){const i=f(m,e,t,n);o.push(i.sbMean),u.push(i.sbSdcm),l+=u[m]}let c,h=l,d=!0;for(;d||l<h;){d=!1,r=[];for(let t=0;t<i;t++)r.push(e[t]);for(let n=0;n<i;n++)for(let r=e[n]+1;r<=e[n+1];r++)if(c=t[r],n>0&&r!==e[n+1]&&Math.abs(c-o[n])>Math.abs(c-o[n-1]))e[n]=r;else if(n<i-1&&e[n]!==r-1&&Math.abs(c-o[n])>Math.abs(c-o[n+1])){e[n+1]=r-1;break}h=l,l=0,s=[],a=[];for(let r=0;r<i;r++){s.push(o[r]),a.push(u[r]);const i=f(r,e,t,n);o[r]=i.sbMean,u[r]=i.sbSdcm,l+=u[r]}}if(l>h){for(let t=0;t<i;t++)e[t]=r[t],o[t]=s[t],u[t]=a[t];l=h}return{mean:o,sdcm:u}}function f(e,t,n,i){let s=0,a=0;for(let r=t[e]+1;r<=t[e+1];r++){const e=i[r];s+=n[r]*e,a+=e}a<=0&&r().warn("Exception in Natural Breaks calculation");const l=s/a;let o=0;for(let r=t[e]+1;r<=t[e+1];r++)o+=i[r]*(n[r]-l)**2;return{sbMean:l,sbSdcm:o}}},21118:(e,t,n)=>{n.d(t,{AL:()=>x,DV:()=>p,ER:()=>r,F_:()=>l,Nd:()=>f,Oo:()=>s,dy:()=>d,eS:()=>_,h4:()=>k,jC:()=>y,nq:()=>m,rZ:()=>h,y6:()=>g});var i=n(50616);const r="Raster.",s="Raster.Dim.",a=".Max",l={servicePixelValue:"Raster.ServicePixelValue",rawServicePixelValue:"Raster.ServicePixelValue.Raw",itemPixelValue:"Raster.ItemPixelValue",magnitude:"Raster.Magnitude",direction:"Raster.Direction",variable:"Raster.Variable"},o=new Map([["quarters","Quarter"],["months","Month"],["weeks","Week of the year"],["days","Day of the year"]]);function u(e,t){return new i.default({name:e,alias:t,domain:null,editable:!1,length:50,type:"string"})}function c(e,t){return new i.default({name:e,alias:t,domain:null,editable:!1,type:"double"})}function h(e){return u(l.servicePixelValue,e??"Service Pixel Value")}function d(e){return u(l.rawServicePixelValue,e??"Raw Service Pixel Value")}function f(){return u(l.itemPixelValue,"Item Pixel Value")}function m(e){return u(`${l.servicePixelValue}.${e}`,e)}function p(e){return c(`${l.magnitude}`,"Magnitude"+(e?` (${e})`:""))}function g(){return c(`${l.direction}`,"Direction (\xb0)")}function y(e){return e.fields.filter((e=>"oid"!==e.type&&"value"!==e.name.toLowerCase())).map((e=>{const t=e.clone();return t.name=`${r}${e.name}`,t}))}function x(e){const t=new Set,n=new Set,r=new Map;return e.variables.forEach((e=>{let{dimensions:i}=e;i.forEach((e=>{if(e.recurring)r.set(e.name,e.unit);else{const i="ISO8601"===e.unit?.trim()?t:n;i.add(e.name),e.hasRanges&&i.add(`${e.name}${a}`)}}))})),[u(l.variable,"Variable"),...[...t].map((e=>function(e,t){return new i.default({name:e,alias:t,domain:null,editable:!1,type:"date"})}(`${s}${e}`,v(e)))),...[...n].map((e=>c(`${s}${e}`,v(e)))),...[...r].map((e=>{let[t,n]=e;return c(`${s}${t}`,b(t,n))}))]}function b(e,t){return t=t?.toLowerCase(),t&&o.has(t)?o.get(t):v(e)}function v(e){const t=e.endsWith(a),n=t?e.slice(0,-4):e,i="StdTime"===n?"Standard Time":"StdZ"===n?"Standard Z":n;return t?`${i} Max`:i}function w(e,t){return t?new Date(e):e}function _(e,t,n){n?.length&&(t[l.variable]=n[0].variableName,n.forEach((n=>{let{dimensionName:i,values:r}=n;if(i&&r?.length){const n=`${s}${i}`,l=e.find((e=>{let{name:t}=e;return t===n}));if(!l)return;const o="date"===l.type,u=r[0];if(Array.isArray(u)){if(t[`${s}${i}`]=w(u[0],o),null!=u[1]){const n=`${s}${i}${a}`;if(e.some((e=>{let{name:t}=e;return t===n}))){const e=w(u[1],o);t[n]=e}}}else t[`${s}${i}`]=w(u,o)}})))}function k(e,t){if(t.pixelType.startsWith("f")&&e.forEach((e=>{let{format:t,fieldName:n}=e;t&&n&&/^raster\.(item|service)pixelvalue/i.test(n)&&(t.places=2)})),t.multidimensionalInfo){const n=t.multidimensionalInfo.variables.flatMap((e=>{let{dimensions:t}=e;return t}));e.forEach((e=>{let{format:t,fieldName:i}=e;if(t&&i?.startsWith(s)){const e=i.slice(s.length),r=`${e}${a}`,l=n.find((t=>{let{name:n}=t;return n===e||n===r}));l?.values?.every((e=>Number.isInteger(e)))&&(t.places=0)}}))}}},43922:(e,t,n)=>{n.d(t,{A:()=>a});var i=n(74719),r=n(34037),s=n(61531);class a{constructor(){this._workerThread=null,this._destroyed=!1}async initialize(){const e=await(0,r.ho)("RasterWorker");this._destroyed?e.close():this._workerThread=e}destroy(){this._destroyed=!0,this._workerThread&&(this._workerThread.close(),this._workerThread=null)}async convertVectorFieldData(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("convertVectorFieldData",{pixelBlock:e.pixelBlock.toJSON(),type:e.dataType},t);return n?new s.default(n):null}computeStatisticsHistograms(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");return this._workerThread.invoke("computeStatisticsHistograms",{pixelBlock:e.pixelBlock.toJSON()},t)}async decode(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("decode",e,t);return n?new s.default(n):null}async symbolize(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n={extent:e.extent?.toJSON(),pixelBlock:e.pixelBlock?.toJSON(),simpleStretchParams:e.simpleStretchParams,bandIds:e.bandIds},r=await this._workerThread.invoke("symbolize",n,t);return r?new s.default(r):null}async updateSymbolizer(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n=e?.rendererJSON?.histograms;await Promise.all(this._workerThread.broadcast("updateSymbolizer",{symbolizerJSON:e.toJSON(),histograms:n},t))}async updateRasterFunction(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");await Promise.all(this._workerThread.broadcast("updateRasterFunction",{rasterFunctionJSON:e.toJSON()},t))}async process(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n=await this._workerThread.invoke("process",{extent:e.extent?.toJSON(),primaryPixelSizes:e.primaryPixelSizes?.map((e=>null!=e?e.toJSON():null)),primaryPixelBlocks:e.primaryPixelBlocks.map((e=>null!=e?e.toJSON():null)),primaryRasterIds:e.primaryRasterIds},t);return n?new s.default(n):null}async stretch(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON(),stretchParams:e.stretchParams},r=await this._workerThread.invoke("stretch",n,t);return r?new s.default(r):null}async split(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON(),tileSize:e.tileSize,maximumPyramidLevel:e.maximumPyramidLevel,useBilinear:e.useBilinear},r=await this._workerThread.invoke("split",n,t);return r&&r.forEach(((e,t)=>{r.set(t,e?s.default.fromJSON(e):null)})),r}async clipTile(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const n={...e,pixelBlock:e.pixelBlock.toJSON()},r=await this._workerThread.invoke("clipTile",n,t);return r?s.default.fromJSON(r):null}async estimateStatisticsHistograms(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");if(!e?.pixelBlock)return null;const n={srcPixelBlock:e.pixelBlock.toJSON()};return await this._workerThread.invoke("estimateStatisticsHistograms",n,t)}async mosaicAndTransform(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");if(!e?.srcPixelBlocks?.length)return{pixelBlock:null};const n={...e,srcPixelBlocks:e.srcPixelBlocks.map((e=>null!=e?e.toJSON():null))},r=await this._workerThread.invoke("mosaicAndTransform",n,t);return{pixelBlock:r.pixelBlock?new s.default(r.pixelBlock):null,localNorthDirections:r.localNorthDirections}}async createFlowMesh(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n={buffer:e.flowData.data.buffer,maskBuffer:e.flowData.mask.buffer,width:e.flowData.width,height:e.flowData.height},{meshType:r,simulationSettings:s}=e,a=await this._workerThread.invoke("createFlowMesh",{meshType:r,flowData:n,simulationSettings:s},{...t,transferList:[n.buffer,n.maskBuffer]});return{vertexData:new Float32Array(a.vertexBuffer),indexData:new Uint32Array(a.indexBuffer)}}getProjectionOffsetGrid(e,t){if(!this._workerThread)throw new i.default("raster-jobhandler:no-connection","no available worker connection");const n=null!=e.datumTransformation?e.datumTransformation.steps.map((e=>({wkid:e.wkid,wkt:e.wkt,isInverse:e.isInverse}))):null,r=null!=e.rasterTransform?e.rasterTransform.toJSON():null,s={projectedExtent:e.projectedExtent.toJSON(),srcBufferExtent:e.srcBufferExtent.toJSON(),pixelSize:e.pixelSize,hasWrapAround:e.hasWrapAround,spacing:e.spacing,datumTransformationSteps:n,rasterTransform:r,isAdaptive:e.isAdaptive,includeGCSGrid:e.includeGCSGrid};return this._workerThread.invoke("getProjectionOffsetGrid",s,t)}}},48270:(e,t,n)=>{function i(e,t){if(!e||!t)return[];let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const r=[];if(t){const s=i(e,n);for(let e=0;e<s.length;e++)i(s[e],t).forEach((e=>r.push(e)));return r}const s=e.getElementsByTagNameNS("*",n);if(!s||0===s.length)return[];for(let i=0;i<s.length;i++)r.push(s[i]||s.item(i));return r}function r(e,t){if(!e||!t)return null;let n=t;t.includes("/")?(n=t.slice(0,t.indexOf("/")),t=t.slice(t.indexOf("/")+1)):t="";const s=i(e,n);return s.length>0?t?r(s[0],t):s[0]:null}function s(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null;const n=t?r(e,t):e;let i;return n?(i=n.textContent||n.nodeValue,i?i.trim():null):null}function a(e,t){const n=i(e,t),r=[];let s;for(let i=0;i<n.length;i++)s=n[i].textContent||n[i].nodeValue,s&&(s=s.trim(),""!==s&&r.push(s));return r}function l(e){const t=s(e,arguments.length>1&&void 0!==arguments[1]?arguments[1]:null);return t?.split(" ").map((e=>Number(e)))??[]}function o(e,t){return a(e,t).map((e=>Number(e)))}function u(e,t){const n=s(e,t);return Number(n)}function c(e,t){const n=e?.nodeName?.toLowerCase(),i=t.toLowerCase();return n.slice(n.lastIndexOf(":")+1)===i}function h(e){return e.nodeName.slice(e.nodeName.lastIndexOf(":")+1)}n.d(t,{Dy:()=>a,IC:()=>i,Ui:()=>o,V6:()=>r,g7:()=>c,mX:()=>s,pN:()=>l,v7:()=>u,vv:()=>h})},56908:(e,t,n)=>{n.d(t,{Gj:()=>d,LF:()=>m,uy:()=>h});var i=n(21965),r=n(99325),s=n(50751),a=n(1501),l=n(95740),o=n(88423),u=n(45581),c=n(31640);const h={key:"type",base:null,typeMap:{"unique-value":u.default,"class-breaks":r.default,"raster-colormap":a.default,"raster-stretch":o.default,"vector-field":c.default,"raster-shaded-relief":l.default,flow:s.default}},d={...h,typeMap:{...h.typeMap}};delete d.typeMap["vector-field"],delete d.typeMap.flow;const f={uniqueValue:u.default,classBreaks:r.default,rasterStretch:o.default,rasterColormap:a.default,vectorField:c.default,rasterShadedRelief:l.default,flowRenderer:s.default};function m(e,t){if(!e)return null;if("classBreaks"===e.type&&e.classificationMethod){const t=e.authoringInfo||{classificationMethod:""};t.classificationMethod=e.classificationMethod,e.authoringInfo=t}"vectorField"===e.type&&e.visualVariables&&!Array.isArray(e.visualVariables)&&(e.visualVariables=[e.visualVariables]);const n=(r=e)&&f[r.type]||null;var r;if(n){const i=new n;return i.read(e,t),i}return t?.messages&&e&&t.messages.push(new i.A("renderer:unsupported","Renderers of type '"+(e.type||"unknown")+"' are not supported",{definition:e,context:t})),null}},59718:(e,t,n)=>{n.r(t),n.d(t,{default:()=>p});var i,r=n(93800),s=n(19455),a=n(48602),l=(n(21265),n(50925),n(14746),n(75269)),o=n(12560),u=n(47800),c=n(65920),h=n(78629),d=n(73848);const f={base:u.default,key:"type",typeMap:{extent:o.default,polygon:c.default}};let m=i=class extends s.A{constructor(e){super(e),this.areaOfInterest=null,this.subsetDefinitions=null}get dimensions(){const{subsetDefinitions:e}=this;if(null==e||0===e.length)return[];const t=new Map;e.forEach((e=>{if(!e.dimensionName)return;let n,i;if(Array.isArray(e.values[0])){const t=e.values;n=t[0][0],i=t[e.values.length-1][1]}else{const t=e.values;n=t[0],i=t[e.values.length-1]}if(t.has(e.dimensionName)){const r=t.get(e.dimensionName);r[0]=Math.min(n,r[0]),r[1]=Math.max(i,r[1])}else t.set(e.dimensionName,[n,i])}));const n=[];for(const i of t)n.push({name:i[0],extent:i[1]});return n}get variables(){const{subsetDefinitions:e}=this;if(null==e||0===e.length)return[];const t=new Set;return e.forEach((e=>{e.variableName&&t.add(e.variableName)})),[...t]}clone(){const e=this.subsetDefinitions?.map((e=>e.clone())),t=this.areaOfInterest?this.areaOfInterest.clone():this.areaOfInterest;return new i({areaOfInterest:t,subsetDefinitions:e})}};(0,r._)([(0,a.MZ)({types:f,json:{read:h.fromJSON,write:!0}})],m.prototype,"areaOfInterest",void 0),(0,r._)([(0,a.MZ)({readOnly:!0})],m.prototype,"dimensions",null),(0,r._)([(0,a.MZ)({readOnly:!0})],m.prototype,"variables",null),(0,r._)([(0,a.MZ)({type:[d.default],json:{write:!0}})],m.prototype,"subsetDefinitions",void 0),m=i=(0,r._)([(0,l.$)("esri.layers.support.MultidimensionalSubset")],m);const p=m},62661:(e,t,n)=>{n.d(t,{jX:()=>c,zo:()=>f,gd:()=>h,ph:()=>l,no:()=>d,kz:()=>o,ht:()=>u,yo:()=>p});var i=n(75400);var r=n(90801);const s=new Map,a=new class{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:15e3,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:5e3;this._timer=null,this._cachedBlocks=new Map,this._size=-1,this._duration=e,this._interval=Math.min(e,t)}decreaseRefCount(e,t){const n=e+"/"+t,i=this._cachedBlocks;if(i.has(n)){const e=i.get(n);return e.refCount--,e.refCount<=0&&(i.delete(n),e.controller&&e.controller.abort()),e.refCount}return 0}getBlock(e,t){const n=e+"/"+t,i=this._cachedBlocks;if(i.has(n)){const e=i.get(n);return e.ts=Date.now(),e.refCount++,i.delete(n),i.set(n,e),e.block}return null}putBlock(e,t,n,i){const r=this._cachedBlocks,s=e+"/"+t;if(r.has(s)){const e=r.get(s);e.ts=Date.now(),e.refCount++}else r.set(s,{block:n,ts:Date.now(),refCount:1,controller:i});this._trim(),this._updateTimer()}deleteBlock(e,t){const n=this._cachedBlocks,i=e+"/"+t;n.has(i)&&n.delete(i)}updateMaxSize(e){this._size=e,this._trim()}empty(){this._cachedBlocks.clear(),this._clearTimer()}getCurrentSize(){return this._cachedBlocks.size}_updateTimer(){if(null!=this._timer)return;const e=this._cachedBlocks;this._timer=setInterval((()=>{const t=Array.from(e),n=Date.now();for(let i=0;i<t.length&&t[i][1].ts<=n-this._duration;i++)e.delete(t[i][0]);0===e.size&&this._clearTimer()}),this._interval)}_trim(){const e=this._cachedBlocks;if(-1===this._size||this._size>=e.size)return;const t=Array.from(e);for(let n=0;n<t.length-this._size;n++)e.delete(t[n][0])}_clearTimer(){null!=this._timer&&(clearInterval(this._timer),this._timer=null)}};function l(e,t){return null==t?e:`${e}?sliceId=${t}`}function o(e,t){const n={extent:null,rasterInfo:t,cache:new Map},i=s.get(e);return i?(i.push(n),i.length-1):(s.set(e,[n]),0)}function u(e,t){const n=s.get(e);n&&(n[t]=null,n.some((e=>null!=e))||s.delete(e))}function c(e,t,n){const i=s.get(e);if(!i)return null==t?a.decreaseRefCount(e,n):0;if(null==t||null==i[t])return a.decreaseRefCount(e,n);const r=i[t]?.cache,l=r?.get(n);if(r&&l){if(l.refCount--,0===l.refCount){r.delete(n);for(let e=0;e<i.length;e++)i[e]?.cache.delete(n);l.controller&&l.controller.abort()}return l.refCount}return 0}function h(e,t,n){const i=s.get(e);if(!i)return null==t?a.getBlock(e,n):null;if(null==t||null==i[t]){for(let e=0;e<i.length;e++){const t=i[e]?.cache.get(n);if(t)return t.refCount++,t.block}return a.getBlock(e,n)}const r=i[t]?.cache.get(n);if(r)return r.refCount++,r.block;for(let s=0;s<i.length;s++){if(s===t||!i[s])continue;const e=i[s]?.cache,r=e?.get(n);if(e&&r)return r.refCount++,e.set(n,r),r.block}return null}function d(e,t,n,i){let r=arguments.length>4&&void 0!==arguments[4]?arguments[4]:null;const l=s.get(e);if(!l)return void(null==t&&a.putBlock(e,n,i,r));if(null==t||null==l[t])return void a.putBlock(e,n,i,r);const o={refCount:1,block:i,isResolved:!1,isRejected:!1,controller:r};i.then((()=>o.isResolved=!0)).catch((()=>o.isRejected=!0)),l[t]?.cache.set(n,o)}function f(e,t,n){const i=s.get(e);i?null!=t&&null!=i[t]?i[t]?.cache.delete(n):a.deleteBlock(e,n):null==t&&a.deleteBlock(e,n)}function m(e,t){const n=s.get(e);return n?n[t]??null:null}function p(e,t,n,s,a,l){let o=arguments.length>6&&void 0!==arguments[6]?arguments[6]:null;const u=m(e,t);if(!u)return;const c=u.extent,{cache:h,rasterInfo:d}=u;if(c&&c.xmin===n.xmin&&c.xmax===n.xmax&&c.ymin===n.ymin&&c.ymax===n.ymax)return;s=s??0;const f=n.clone().normalize(),{spatialReference:p,transform:g}=d,y=new Set;for(let m=0;m<f.length;m++){const e=f[m];if(e.xmax-e.xmin<=s||e.ymax-e.ymin<=s)continue;let t=(0,r._l)(e,p,o);null!=g&&(t=g.inverseTransform(t));const n=new i.default({x:s,y:s,spatialReference:e.spatialReference});if(null==a&&!(a=(0,r.Wo)(n,p,e,o)))return;const{pyramidLevel:u,pyramidResolution:c,excessiveReading:h}=(0,r.t$)(a,d,l||"closest");if(h)return;const{storageInfo:x}=d,{origin:b}=x,{x:v,y:w}=c,_=Math.max(0,Math.floor((t.xmin-b.x)/v)),k=Math.max(0,Math.floor((b.y-t.ymax)/w)),I=Math.ceil(t.width/v-.1),S=Math.ceil(t.height/w-.1),R=u>0?x.pyramidBlockWidth:x.blockWidth,M=u>0?x.pyramidBlockHeight:x.blockHeight,T=x.blockBoundary[u];if(!T)continue;const F=1,N=Math.max(T.minCol,Math.floor(_/R)-F),D=Math.max(T.minRow,Math.floor(k/M)-F),C=Math.min(T.maxCol,Math.floor((_+I-1)/R)+F),P=Math.min(T.maxRow,Math.floor((k+S-1)/M)+F);for(let i=D;i<=P;i++)for(let e=N;e<=C;e++)y.add(`${u}/${i}/${e}`)}h.forEach(((e,t)=>{if(!y.has(t)){const e=h.get(t);(null==e||e.isResolved||e.isRejected)&&h.delete(t)}})),u.extent={xmin:n.xmin,ymin:n.ymin,xmax:n.xmax,ymax:n.ymax}}},68170:(e,t,n)=>{n.d(t,{o:()=>J});var i=n(93800),r=n(23060),s=n(74719),a=n(50925),l=n(48602),o=n(80556),u=(n(21265),n(14746),n(47332)),c=n(14800),h=n(75269),d=n(75400),f=n(93321),m=n(70576),p=n(65073),g=n(75238),y=n(73848),x=n(59718),b=n(24889),v=n(84766),w=n(43922),_=n(4126),k=n(78800),I=n(74706),S=n(67726),R=n(65231),M=n(90801),T=n(47659),F=n(21543),N=n(76874),D=n(27181),C=n(56908),P=n(45643),B=n(65078);const J=e=>{let t=class extends e{constructor(){super(...arguments),this._isConstructedFromFunctionRaster=!1,this._rasterJobHandler={instance:null,refCount:0,connectionPromise:null},this.bandIds=null,this.copyright=null,this.interpolation=null,this.multidimensionalSubset=null,this.raster=null,this.serviceRasterInfo=null,this.sourceJSON=null,this.spatialReference=null,this.symbolizer=null,this._isConstructedFromFunctionRaster="Function"===(arguments.length<=0?void 0:arguments[0])?.raster?.datasetFormat}get fullExtent(){return this.serviceRasterInfo?.extent}set multidimensionalDefinition(e){this._set("multidimensionalDefinition",e),this.updateRenderer()}set rasterFunction(e){"none"===e?.functionName?.toLowerCase()&&(e=void 0),this._set("rasterFunction",e),this.updateRasterFunction()}set url(e){this._set("url",(0,p.Jf)(e,a.A.getLogger(this)))}get renderer(){if("imagery-tile"!==this.type)return this.internalRenderer;const{activePresetRendererName:e,presetRenderers:t}=this;if(e){const n=t?.find((t=>{let{name:n}=t;return n===e}));return n?.renderer.clone()}return this.internalRenderer}set renderer(e){"imagery-tile"===this.type&&(this.activePresetRendererName=null),this.internalRenderer=e}set internalRenderer(e){null==e&&null==this.rasterFunction?this._configDefaultRenderer("override"):(this._set("internalRenderer",e),this.updateRenderer())}readRenderer(e,t,n){const i=t?.layerDefinition?.drawingInfo?.renderer;return(0,C.LF)(i,n)||void 0}async convertVectorFieldData(e,t){const{serviceRasterInfo:n}=this;if(null==e||!n)return null;const i=this._rasterJobHandler.instance,r=n.dataType;return i?i.convertVectorFieldData({pixelBlock:e,dataType:r},t):(0,F.FI)(e,r)}async computeStatisticsHistograms(e,t){await this.load(t),e=(0,o.PZ)(P.default,e).clone();const{serviceRasterInfo:n}=this;if(null==n)throw new s.default("imagery-tile-mixin:compute-statistics-histograms","serviceRasterInfo must be specified");const{geometry:i}=e;if(null==i)throw new s.default("imagery-tile-mixin:compute-statistics-histograms","geometry must be specified");let r=i;const{spatialReference:a}=n;i.spatialReference.equals(a)||(await(0,M.Hh)(),r="extent"===i.type?(0,M._l)(i,a):(0,M.uk)(i,a));const l=e.pixelSize??new d.default({x:n.pixelSize.x,y:n.pixelSize.y,spatialReference:a}),{extent:u,width:c,height:h}=(0,S.b7)(n,r,l),f=await this.fetchPixels(u,c,h,{...t,interpolation:"nearest"});if(null==f.pixelBlock)throw new s.default("imagery-tile-mixin:compute-statistics-histograms","failed to fetch pixels");const m=await(0,S.$Q)(f.pixelBlock,u,r),p=this._rasterJobHandler.instance;return p?p.computeStatisticsHistograms({pixelBlock:m},t):(0,T.eH)(m)}async createFlowMesh(e,t){const n=this._rasterJobHandler.instance;return n?n.createFlowMesh(e,t):(0,B.CW)(e.meshType,e.simulationSettings,e.flowData,null!=t.signal?t.signal:(new AbortController).signal)}normalizeRasterFetchOptions(e){const{multidimensionalInfo:t}=this.serviceRasterInfo??{};if(null==t)return e;const n=(0,I.XU)({rasterInfo:this.raster.rasterInfo,multidimensionalDefinition:e.multidimensionalDefinition||this.multidimensionalDefinition,timeExtent:e.timeExtent??this.timeExtent,multidimensionalSubset:this.multidimensionalSubset});return{...e,multidimensionalDefinition:n}}async updateRasterFunction(){return this.loaded&&"imagery-tile"===this.type&&(this.rasterFunction||this._cachedRasterFunctionJson)&&JSON.stringify(this.rasterFunction)!==JSON.stringify(this._cachedRasterFunctionJson)?(this._cachedRasterFunctionJson=this.rasterFunction?.toJSON(),this._rasterFunctionUpdatePromise=this._updateRasterFunction(),this._rasterFunctionUpdatePromise):this._rasterFunctionUpdatePromise}async updateRenderer(){const{loaded:e,symbolizer:t}=this;if(!e||!t||!this.renderer)return;const{rasterInfo:n}=this.raster,i=(0,I.ct)(n,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=i?.name,s=(0,N.$P)({...this.renderer.toJSON(),variableName:r});if(JSON.stringify(this._cachedRendererJson)===JSON.stringify(s))return;const a=this._rasterJobHandler.instance;a&&(t.rasterInfo=(0,N.m7)(n,r),t.rendererJSON=s,t.bind(),await a.updateSymbolizer(t),this._cachedRendererJson=s)}async applyRenderer(e,t){const n=e?.pixelBlock;if(!(null!=n&&n.pixels&&n.pixels.length>0))return null;let i;await this.updateRenderer();const r=this._rasterJobHandler.instance,s=this.bandIds??[];return i=r?await r.symbolize({...e,simpleStretchParams:t,bandIds:s}):this.symbolizer.symbolize({...e,simpleStretchParams:t,bandIds:s}),i}getTileUrl(e,t,n){return"RasterTileServer"===this.raster.datasetFormat?`${this.url}/tile/${e}/${t}/${n}`:""}getCompatibleTileInfo(e,t){let n=arguments.length>2&&void 0!==arguments[2]&&arguments[2];if(!this.loaded||null==t)return null;if(n&&e.equals(this.spatialReference))return this.tileInfo;const i=(0,m.Vp)(e);return _.default.create({size:256,spatialReference:e,origin:i?{x:i.origin[0],y:i.origin[1]}:{x:t.xmin,y:t.ymax}})}getCompatibleFullExtent(e){return this.loaded?(this._compatibleFullExtent?.spatialReference.equals(e)||(this._compatibleFullExtent=this.raster.computeExtent(e)),this._compatibleFullExtent):null}async fetchTile(e,t,i){let s=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};if(n(this),s.requestAsImageElement){const n=this.getTileUrl(e,t,i);return(0,r.default)(n,{responseType:"image",query:{...this.refreshParameters,...this.raster.ioConfig.customFetchParameters},signal:s.signal}).then((e=>e.data))}const{serviceRasterInfo:a}=this;if(null!=a.multidimensionalInfo&&null==(s=this.normalizeRasterFetchOptions(s)).multidimensionalDefinition){const n=s.tileInfo||a.storageInfo.tileInfo;return{extent:this.raster.getTileExtentFromTileInfo(e,t,i,n),pixelBlock:null}}return await this._initJobHandler(),await this.updateRasterFunction(),"raster-shaded-relief"===this.renderer?.type&&(s={...s,buffer:{cols:1,rows:1}}),this.raster.fetchTile(e,t,i,s)}async fetchPixels(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};return null!=this.serviceRasterInfo.multidimensionalInfo&&null==(i=this.normalizeRasterFetchOptions(i)).multidimensionalDefinition?{extent:e,pixelBlock:null}:(await this._initJobHandler(),await this.updateRasterFunction(),t=Math.round(t),n=Math.round(n),this.raster.fetchPixels(e,t,n,i))}async identify(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};await this.load();const{raster:n,serviceRasterInfo:i}=this;if(null!=i?.multidimensionalInfo&&(!i.hasMultidimensionalTranspose||!((0,I.DY)(t.multidimensionalDefinition)||t.transposedVariableName||t.timeExtent))&&null==(t=this.normalizeRasterFetchOptions(t)).multidimensionalDefinition)return{location:e,value:null};const r=this.multidimensionalSubset?.areaOfInterest;if(r&&!r.contains(e))throw new s.default("imagery-tile-mixin:identify","the request cannot be fulfilled when falling outside of the multidimensional subset");return n.identify(e,t)}increaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount++}decreaseRasterJobHandlerUsage(){this._rasterJobHandler.refCount--,this._rasterJobHandler.refCount<=0&&this._shutdownJobHandler()}hasStandardTime(){const e=this.serviceRasterInfo?.multidimensionalInfo;if(null==e||"standard-time"!==this.serviceRasterInfo?.dataType)return!1;const t=this.multidimensionalDefinition,n=t?.[0]?.variableName;return e.variables.some((e=>e.name===n&&(!t?.[0].dimensionName||e.dimensions.some((e=>"StdTime"===e.name)))))}getStandardTimeValue(e){return new Date((0,I.$E)(e)).toISOString()}getMultidimensionalSubsetVariables(e){const t=e??this.serviceRasterInfo?.multidimensionalInfo;return(0,I.z2)(this.multidimensionalSubset,t)}_configDefaultSettings(){this._configDefaultInterpolation(),this.multidimensionalDefinition||(this.multidimensionalDefinition=(0,I.fy)(this.raster.rasterInfo,{multidimensionalSubset:this.multidimensionalSubset})),this.rasterFunction&&"Function"===this.raster.datasetFormat&&(this._cachedRasterFunctionJson=this.rasterFunction.toJSON()),this._configDefaultRenderer()}_initJobHandler(){if(null!=this._rasterJobHandler.connectionPromise)return this._rasterJobHandler.connectionPromise;const e=new w.A;return this._rasterJobHandler.connectionPromise=e.initialize().then((async()=>{n(this),this._rasterJobHandler.instance=e,this.raster.rasterJobHandler=e,"Function"===this.raster.datasetFormat&&this.raster.syncJobHandler(),this.rasterFunction&&await this.updateRasterFunction().catch((()=>{})),this.renderer&&this.updateRenderer()})).catch((()=>{})),this._rasterJobHandler.connectionPromise}_shutdownJobHandler(){this._rasterJobHandler.instance&&this._rasterJobHandler.instance.destroy(),this._rasterJobHandler.instance=null,this._rasterJobHandler.connectionPromise=null,this._rasterJobHandler.refCount=0,this._cachedRendererJson=null,this.raster&&(this.raster.rasterJobHandler=null)}_configDefaultInterpolation(){if(null==this.interpolation){n(this);const{raster:e}=this,t=(0,N.w6)(e.rasterInfo,e.tileType,this.sourceJSON?.defaultResamplingMethod);this._set("interpolation",t)}}_configDefaultRenderer(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:"no";n(this);const{rasterInfo:t}=this.raster,i=(0,I.ct)(t,{multidimensionalDefinition:this.multidimensionalDefinition,multidimensionalSubset:this.multidimensionalSubset}),r=i?.name,s=(0,N.I8)({variableName:r,rasterFunctionName:this.rasterFunction?.functionName,presetRenderers:this.presetRenderers});if(!this.bandIds&&t.bandCount>1&&(this.bandIds=s?.bandIds??(0,N.ci)(t)),!this.renderer||"override"===e){const e=(0,N.Mm)(this.raster),n=s?.renderer??(0,N.PD)(t,{bandIds:this.bandIds,variableName:r,rasterFunctionColorRamp:e}),i=t.statistics,a=i&&i.length>0?i[0]:null,l=a?.max??0,o=a?.min??0;"WCSServer"===this.raster.datasetFormat&&"raster-stretch"===n.type&&(l>1e24||o<-1e24)&&(n.dynamicRangeAdjustment=!0,n.customStatistics=null,"none"===n.stretchType&&(n.stretchType="min-max")),this.renderer=n}const l=(0,N.$P)({...this.renderer.toJSON(),variableName:r}),o=(0,N.m7)(t,r);this.symbolizer?(this.symbolizer.rendererJSON=l,this.symbolizer.rasterInfo=o):this.symbolizer=new D.A({rendererJSON:l,rasterInfo:o});const u=this.symbolizer.bind();if(u.success){if("auto"===e){const{colormap:e}=this.raster.rasterInfo,t=this.renderer;if(null!=e&&"raster-colormap"===t.type){const e=(0,N.PD)(this.raster.rasterInfo);JSON.stringify(e)!==JSON.stringify(t)&&this._configDefaultRenderer("override")}else if("raster-stretch"===t.type){const e=this.bandIds?.length,n=t.customStatistics?.length;!t.dynamicRangeAdjustment&&n&&e&&n!==e&&this._configDefaultRenderer("override")}}}else a.A.getLogger(this).warn("imagery-tile-mixin",u.error||"The given renderer is not supported by the layer."),"auto"===e&&this._configDefaultRenderer("override")}async _updateRasterFunction(){if(this._isConstructedFromFunctionRaster&&"Function"===this.raster.datasetFormat){const e=this.raster.rasterFunction.toJSON();return void(!this.rasterFunction&&e&&this._set("rasterFunction",v.default.fromJSON(e)))}let e,t=this.raster,n=!1;"Function"===t.datasetFormat?(e=t.primaryRasters.rasters,t=e[0],n=!0):e=[t];const{rasterFunction:i}=this;if(i){const n={raster:t};e.length>1&&e.forEach((e=>n[e.url]=e));const r=(0,R.vt)(i.functionDefinition?.toJSON()??i.toJSON(),n),s=new k.A({rasterFunction:r});s.rasterJobHandler=this._rasterJobHandler.instance,await s.open(),this.raster=s}else this.raster=t,await t.open();if(this._cachedRendererJson=null,!n&&!i)return;const{bandIds:r}=this,{bandCount:s}=this.raster.rasterInfo,a=r?.length?r.some((e=>e>=s)):s>=3;r&&(a||this.renderer&&"raster-stretch"!==this.renderer.type)&&this._set("bandIds",null),this._configDefaultRenderer("auto")}};function n(e){if(!e.raster||!e.serviceRasterInfo)throw new s.default("imagery-tile","no raster")}return(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_cachedRendererJson",void 0),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_cachedRasterFunctionJson",void 0),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_compatibleFullExtent",void 0),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_isConstructedFromFunctionRaster",void 0),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_rasterJobHandler",void 0),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"_rasterFunctionUpdatePromise",void 0),(0,i._)([(0,l.MZ)({type:[o.jz],json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"0,1,2"!==this.bandIds?.join(",")}}}}})],t.prototype,"bandIds",void 0),(0,i._)([(0,l.MZ)({json:{origins:{service:{read:{source:"copyrightText"}}}}})],t.prototype,"copyright",void 0),(0,i._)([(0,l.MZ)({json:{read:!1}})],t.prototype,"fullExtent",null),(0,i._)([(0,l.MZ)({json:{write:{overridePolicy(){return{enabled:!this.loaded||"Raster"===this.raster.tileType||"bilinear"!==this.interpolation}}}}}),(0,u.e)(b.SZ)],t.prototype,"interpolation",void 0),(0,i._)([(0,l.MZ)()],t.prototype,"ioConfig",void 0),(0,i._)([(0,l.MZ)({type:[y.default],json:{write:!0}})],t.prototype,"multidimensionalDefinition",null),(0,i._)([(0,l.MZ)({type:x.default,json:{write:!0}})],t.prototype,"multidimensionalSubset",void 0),(0,i._)([(0,l.MZ)()],t.prototype,"raster",void 0),(0,i._)([(0,l.MZ)({type:v.default})],t.prototype,"rasterFunction",null),(0,i._)([(0,l.MZ)()],t.prototype,"serviceRasterInfo",void 0),(0,i._)([(0,l.MZ)()],t.prototype,"sourceJSON",void 0),(0,i._)([(0,l.MZ)({readOnly:!0,type:f.default,json:{read:!1}})],t.prototype,"spatialReference",void 0),(0,i._)([(0,l.MZ)({type:_.default})],t.prototype,"tileInfo",void 0),(0,i._)([(0,l.MZ)(g.OZ)],t.prototype,"url",null),(0,i._)([(0,l.MZ)()],t.prototype,"renderer",null),(0,i._)([(0,l.MZ)({types:C.uy,json:{name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy(){const e="raster-stretch"===this.renderer?.type&&"none"===this.renderer.stretchType&&!this.renderer.useGamma;return{enabled:!this.loaded||"Raster"===this.raster.tileType||!e}}},origins:{"web-scene":{types:C.Gj,name:"layerDefinition.drawingInfo.renderer",write:{overridePolicy:e=>({enabled:e&&"vector-field"!==e.type&&"flow"!==e.type})}}}}})],t.prototype,"internalRenderer",null),(0,i._)([(0,c.w)("internalRenderer")],t.prototype,"readRenderer",null),(0,i._)([(0,l.MZ)({clonable:!1})],t.prototype,"symbolizer",void 0),t=(0,i._)([(0,h.$)("esri.layers.mixins.ImageryTileMixin")],t),t}},74706:(e,t,n)=>{n.d(t,{$E:()=>k,DY:()=>y,NG:()=>_,QW:()=>a,Rp:()=>f,XU:()=>m,Xg:()=>w,ct:()=>p,fy:()=>g,sx:()=>d,xx:()=>l,z2:()=>x});var i=n(62631),r=n(73848);function s(e,t,n){const i=t.shift();if(0===n.length){const e=[];n.push({sliceId:-1,multidimensionalDefinition:e})}const r=n.length;for(let s=0;s<r;s++){const t=n.shift().multidimensionalDefinition;i.values?.forEach((r=>{n.push({sliceId:-1,multidimensionalDefinition:[...t,{variableName:e,dimensionName:i.name,values:[r]}]})}))}t.length&&s(e,t,n)}function a(e,t){const n=[];let i=0;return(t?e.variables.filter((e=>e.name.toLowerCase()===t.toLowerCase())):[...e.variables].sort(((e,t)=>e.name>t.name?1:-1))).forEach((e=>{const t=[],r=[...e.dimensions].sort(((e,t)=>e.name>t.name?-1:1));s(e.name,r,t),t.forEach((e=>{n.push({...e,sliceId:i++})}))})),n}function l(e,t,n){let i=e;if(t&&(t=[...t].sort(((e,t)=>e.dimensionName<t.dimensionName?-1:1))).forEach((e=>{let{dimensionName:t,values:n,isSlice:r}=e;n.length&&(i=i.filter((e=>{const i=e.multidimensionalDefinition.find((e=>e.dimensionName===t));if(null==i)return!1;const s=i.values[0];return"number"==typeof s?"number"==typeof n[0]?n.includes(s):n.some((e=>e[0]<=s&&e[1]>=s)):"number"==typeof n[0]?n.some((e=>s[0]<=e&&s[1]>=e)):r?n.some((e=>e[0]===s[0]&&e[0]===s[1])):n.some((e=>e[0]>=s[0]&&e[0]<=s[1]||e[1]>=s[0]&&e[1]<=s[1]||e[0]<s[0]&&e[1]>s[1]))})))})),i.length&&null!=n?.start&&null!=n.end){const e=n.start.getTime(),t=n.end.getTime(),r=i[0].multidimensionalDefinition.findIndex((e=>"StdTime"===e.dimensionName));r>-1&&(i=i.filter((n=>{const i=n.multidimensionalDefinition[r].values[0];return e<=i&&t>=i})))}return i.map((e=>e.sliceId))}function o(e,t){return Array.isArray(e)?t[0]===t[1]?e[0]===t[0]||e[1]===t[0]:e[0]>=t[0]&&e[0]<=t[1]&&e[1]>=t[0]&&e[1]<=t[1]:e>=t[0]&&e<=t[1]}function u(e,t){return e[0]<=t[0]&&e[1]>=t[0]||e[0]<=t[1]&&e[1]>=t[1]||e[0]>=t[0]&&e[1]<=t[1]}function c(e){return 1===e.length?[e[0],e[0]]:[e[0],e[e.length-1]]}function h(e,t,n){if(!t?.subsetDefinitions?.length)return e;let i;if(n){const{variables:r}=t;if(r.length&&!r.includes(n))return null;const s=t.subsetDefinitions.find((t=>t.dimensionName===e.name&&t.variableName===n));if(!s?.values?.length)return e;i=c(s.values)}else{const n=t.dimensions.find((t=>{let{name:n}=t;return n===e.name}));i=n?.extent}const r=i;if(!r?.length)return e;const s=e.values.filter((e=>o(e,r)));return{...e,extent:[...r],values:s}}function d(e,t,n){if(!t?.subsetDefinitions?.length)return!1;const{variables:i}=t;if(i.length&&e.some((e=>{let{variableName:t}=e;return t&&!i.includes(t)})))return!0;for(let r=0;r<e.length;r++){const i=e[r],s=t.subsetDefinitions.find((e=>(""===i.variableName||e.variableName===i.variableName)&&e.dimensionName===i.dimensionName));if(s?.values.length){const e=c(s.values);if(i.isSlice||2!==i.values.length||Array.isArray(i.values[0])||i.values[0]===i.values[1]||!n){if(i.values.some((t=>!o(t,e))))return!0}else if(!u(i.values,e))return!0}}return!1}function f(e,t){if(null==e)return{isOutside:!1};const{geometry:n,timeExtent:i,multidimensionalDefinition:s}=t;let a=null;if(null!=i&&(a=function(e,t){const n=e.dimensions.find((e=>{let{name:t}=e;return"StdTime"===t}));if(null==n||null==t.start&&null==t.end)return t;t=t.clone();const{start:i,end:s}=t.toJSON(),a=i===s?[i]:null!=i&&null!=s?[i,s]:[i??s];return 2===a.length&&n?.extent.length&&(a[0]=Math.max(a[0],n.extent[0]),a[1]=Math.min(a[1],n.extent[1]??n.extent[0]),a[1]<a[0])||d([new r.default({variableName:"",dimensionName:"StdTime",isSlice:1===a.length,values:a})],e,!0)?null:(t.start=new Date(a[0]),t.end=new Date(a[1]??a[0]),t)}(e,i),null==a))return{isOutside:!0};const{areaOfInterest:l}=e;if(l&&n){const e="point"===n.type?n:"extent"===n.type?n.center:"polygon"===n.type?n.centroid:null;if(e&&!l.contains(e))return{isOutside:!0}}return null!=s&&s.length&&d(s,e,!0)?{isOutside:!0}:{isOutside:!1,intersection:{geometry:n,timeExtent:a,multidimensionalDefinition:s}}}function m(e){const{rasterInfo:t,multidimensionalSubset:n}=e,{multidimensionalInfo:i}=t;if(null==i)return null;let r=e.multidimensionalDefinition?.length?e.multidimensionalDefinition:g(t,{multidimensionalSubset:n});if(!r?.length)return null;if(r.some((e=>!e.dimensionName))){const{variableName:e}=r[0],i=g(t,{multidimensionalSubset:n,variableName:e});i?.forEach((e=>{const t=r?.find((t=>{let{dimensionName:n}=t;return n===e.dimensionName}));t?.values?.length&&(e.values=t.values,e.isSlice=t.isSlice)})),r=i}const{timeExtent:s}=e;if(null!=r&&null!=s&&(null!=s.start||null!=s.end)){r=r.map((e=>e.clone()));const e=i.variables.find((e=>{let{name:t}=e;return t===r[0].variableName}))?.dimensions?.find((e=>{let{name:t}=e;return"StdTime"===t})),t=r.find((e=>{let{dimensionName:t}=e;return"StdTime"===t}));if(!e||!t)return null;const{start:n,end:a}=s,l=null==n?null:n.getTime(),o=null==a?null:a.getTime(),u=l??o,c=o??l;if(null!=e.values){const n=e.values.filter((e=>{if(Array.isArray(e)){if(u===c)return e[0]<=u&&e[1]>=u;const t=e[0]<=u&&e[1]>u||e[0]<c&&e[1]>=c,n=e[0]>=u&&e[1]<=c||e[0]<u&&e[1]>c;return t||n}return u===c?e===u:e>=u&&e<=c}));if(n.length){const e=n.sort(((e,t)=>{const n=Array.isArray(e)?e[0]:e,i=Array.isArray(e)?e[1]:e,r=Array.isArray(t)?t[0]:t,s=Array.isArray(t)?t[1]:t;return u===c?n-r:Math.abs(i-c)-Math.abs(s-c)}))[0];t.values=[e]}else r=null}else if(e.hasRegularIntervals&&e.extent){const[n,i]=e.extent;u>i||c<n?r=null:t.values=u===c?[u]:[Math.max(n,u),Math.min(i,c)]}}return null!=r&&d(r,n)?null:r}function p(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const{multidimensionalInfo:n,keyProperties:i}=e;if(null==n)return null;const{variableName:r,multidimensionalSubset:s,multidimensionalDefinition:a}=t,l=null!=a?a[0]?.variableName:null,o=r||l||i?.DefaultVariable;let{variables:u}=n;return s?.variables?.length&&(u=u.filter((e=>{let{name:t}=e;return s.variables.includes(t)}))),o?u.find((e=>{let{name:t}=e;return t===o}))??u[0]:u[0]}function g(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};const n=p(e,t);if(!n)return null;const i=[],{dimensions:s,name:a}=n;if(0===s.length)return[new r.default({variableName:a,dimensionName:"",values:[],isSlice:!0})];for(let l=0;l<s.length;l++){const e=h(s[l],t.multidimensionalSubset,a);if(!e)return null;const{values:n,extent:o}=e;let u=n?.[0]??o?.[0];"stdz"===e.name.toLowerCase()&&!e.hasRanges&&o&&Math.abs(o[1])<=Math.abs(o[0])&&(u=n?.length?n[n.length-1]:o[1]),i.push(new r.default({variableName:a,dimensionName:e.name,values:[u],isSlice:!t.useRangeForRangedDimensionInfo||!!e.hasRanges}))}return i}function y(e){return!!e?.length&&e.some((e=>{if(null==e.values)return!0;const t=e.values.length;return 0===t||t>1||!e.isSlice&&Array.isArray(e.values[0])}))}function x(e,t){if(null==t||null==e)return null;let n=t.variables.map((e=>({...e})));return e?.variables?.length&&(n=n.filter((t=>{let{name:n}=t;return e.variables.includes(n)})),n.forEach((t=>{t.dimensions=t.dimensions.map((n=>h(n,e,t.name))).filter(i.Ru)}))),n}function b(e,t){const{values:n}=t;if(n?.length){const t=Array.isArray(n[0]),i=Array.isArray(e);return t!==i?-1:t&&i?n.findIndex((t=>t[0]===e[0]&&t[1]===e[1])):n.indexOf(e)}const{extent:i}=t;if(Array.isArray(e)||!i||e<i[0]||e>i[1])return-1;const r=t.interval||1;if("ISO8601"!==t.unit)return Math.round((e-i[0])/r);const s=i[0];let a=-1;switch(t.intervalUnit?.toLowerCase()||"days"){case"seconds":a=Math.round((e-s)/1e3/r);break;case"minutes":a=Math.round((e-s)/6e4/r);break;case"hours":a=Math.round((e-s)/36e5/r);break;case"days":a=Math.round((e-s)/864e5/r);break;case"months":{const t=new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear(),n=new Date(s).getUTCMonth(),i=new Date(e).getUTCMonth();a=0===t?i-n:i+11-n+12*(t-1)}break;case"years":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/r);break;case"decades":a=Math.round((new Date(e).getUTCFullYear()-new Date(s).getUTCFullYear())/10/r)}return a}function v(e){let t=e.values?.length;if(t)return t;const{extent:n,unit:i}=e,r=e.interval||1,s=n?n[1]-n[0]:0;if("ISO8601"!==i)return Math.round(s/r);switch(e.intervalUnit?.toLowerCase()??"seconds"){case"seconds":t=Math.round(s/1e3/r);break;case"minutes":t=Math.round(s/6e4/r);break;case"hours":t=Math.round(s/36e5/r);break;case"days":t=Math.round(s/864e5/r);break;case"months":if(n){const e=new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear(),i=new Date(n[0]).getUTCMonth(),r=new Date(n[1]).getUTCMonth();t=0===e?r-i+1:r+11-i+12*(e-1)+1}else t=0;break;case"years":t=n?Math.round((new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear())/r):0;break;case"decades":t=n?Math.round((new Date(n[1]).getUTCFullYear()-new Date(n[0]).getUTCFullYear())/10/r):0;break;default:t=0}return t}function w(e){if(2!==e.extent?.length||!e.interval)return[];const{extent:[t,n],interval:i}=e;if("ISO8601"===e.unit){const r=e.intervalUnit?.toLowerCase()??"days";return["decades","years","months","days","hours","minutes","seconds"].includes(r)?function(e,t,n,i){const r=[];let s=e;const a=new Date(e);for(;s<=t;)switch(r.push(s),i){case"decades":a.setUTCFullYear(a.getUTCFullYear()+10*n),s=a.getTime();break;case"years":a.setUTCFullYear(a.getUTCFullYear()+n),s=a.getTime();break;case"months":a.setUTCMonth(a.getUTCMonth()+n),s=a.getTime();break;case"days":s+=864e5*n;break;case"hours":s+=36e5*n;break;case"minutes":s+=6e4*n;break;case"seconds":s+=1e3*n}return 1===r.length?r[1]=t:r[r.length-1]=t,r}(t,n,i,r):[]}const r=Math.round((n-t)/i);return Array.from({length:r},((e,s)=>s===r-1?n:t+s*i))}function _(e,t){let n=0;const i=e[0].variableName,r=[...t.variables].sort(((e,t)=>e.name>t.name?1:-1));for(let s=0;s<r.length;s++){const t=r[s],a=[...t.dimensions].sort(((e,t)=>e.name>t.name?-1:1));if(t.name!==i){n+=a.map((e=>v(e))).reduce(((e,t)=>e*t));continue}const l=a.map((e=>v(e))),o=a.length;for(let i=0;i<o;i++){const t=e.find((e=>e.dimensionName===a[i].name));if(null==t)return null;const r=b(t.values[0],a[i]);if(-1===r)return null;l.shift(),n+=i===o-1?r:r*l.reduce(((e,t)=>e*t))}break}return n}function k(e){return Math.round(24*(e-25569)*3600*1e3)}},78800:(e,t,n)=>{n.d(t,{A:()=>m});var i=n(93800),r=n(74719),s=n(48602),a=(n(21265),n(50925),n(14746),n(75269)),l=n(65920),o=n(86981),u=n(67726),c=n(50396),h=n(90801),d=n(87520);let f=class extends o.A{constructor(){super(...arguments),this.datasetFormat="Function",this.tileType="Raster",this.rasterFunction=null,this._clippingGeometry=new Map}async fetchPixels(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const{rasters:r,rasterIds:s}=this.primaryRasters;let a=!1;const{interpolation:l}=i,o=this.rasterFunction.flatWebGLFunctionChain?.hasFocalFunction;!i.requestRawData&&o&&(a=1===r.length&&!i.skipRasterFunction,i={...i,interpolation:"bilinear",requestRawData:a});const h=r.map((r=>r.fetchPixels(e,t,n,i))),d=await Promise.all(h),f=d.map((e=>e.pixelBlock)),m=a||i.requestRawData?d.map((e=>e.srcTilePixelSize)):null;if(i.skipRasterFunction||f.every((e=>null==e)))return d[0];const p=d.find((e=>null!=e.pixelBlock))?.extent??e;let g=this.rasterJobHandler?await this.rasterJobHandler.process({extent:p,primaryPixelBlocks:f,primaryPixelSizes:m,primaryRasterIds:s}):this.rasterFunction.process({extent:p,primaryPixelBlocks:f,primaryPixelSizes:m,primaryRasterIds:s});const{transformGrid:y}=d[0];if(!a||null==g||null==y){const e=i.noClip?null:this.getClippingGeometry(p.spatialReference);return i.noClip||i.requestRawData||null==g||!e||(g=await(0,u.$Q)(g,p,e)),{...d[0],pixelBlock:g}}const x={rows:y.spacing[0],cols:y.spacing[1]};let b;b=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:[g],srcMosaicSize:{width:g.width,height:g.height},destDimension:{width:t,height:n},coefs:y.coefficients,sampleSpacing:x,projectDirections:!1,gcsGrid:null,isUV:!1,interpolation:l,alignmentInfo:void 0,blockWidths:null},i)).pixelBlock:(0,c.$i)(g,{width:t,height:n},y.coefficients,x,l);const v=i.noClip?null:this.getClippingGeometry(e.spatialReference);return i.noClip||i.requestRawData||null==b||null==v||(b=await(0,u.$Q)(b,e,v)),{extent:e,srcExtent:d[0].srcExtent,pixelBlock:b}}getClippingGeometry(e){const t=this._clippingGeometry.get("0");if(!e||!t)return t;const n=function(e){return String(e.wkid??e.wkt??e.wkt2)}(e);let i=this._clippingGeometry.get(n);return null!=i||(i=e.equals(t.spatialReference)?t:(0,h.uk)(t,e),this._clippingGeometry.set(n,i)),i}async _open(e){const{rasterFunction:t}=this;this.primaryRasters?.rasters?.length?t.sourceRasters=this.primaryRasters.rasters:(this.primaryRasters=t.getPrimaryRasters(),this.rasterJobHandler&&this.primaryRasters.rasters?.forEach((e=>e.rasterJobHandler=this.rasterJobHandler)));const{rasters:n,rasterIds:i}=this.primaryRasters,s=n.map((t=>t.rasterInfo?void 0:t.open(e)));await Promise.all(s);const a=n.map((e=>{let{rasterInfo:t}=e;return t})),l=t.bind({rasterInfos:a,rasterIds:i});if(t.rawSourceRasterInfos=a,!l.success||0===a.length)throw new r.default("raster-function:open",`cannot bind the function: ${l.error??""}`);const o="Table"===t.functionName?t:t.functionArguments?.raster;"Table"===o?.functionName&&(t.rasterInfo.attributeTable=d.default.fromJSON(o.functionArguments.attributeTableAsRecordSet)),await this.syncJobHandler();const u=a[0];this.hasUniqueSourceStorageInfo=1===a.length||a.slice(1).every((e=>function(e,t){const{storageInfo:n,pixelSize:i,spatialReference:r,extent:s}=e,{storageInfo:a,pixelSize:l,spatialReference:o,extent:u}=t;return i.x===l.x&&i.y===l.y&&r.equals(o)&&s.equals(u)&&n.blockHeight===a.blockHeight&&n.blockWidth===a.blockWidth&&n.maximumPyramidLevel===a.maximumPyramidLevel}(e,u))),this.set("sourceJSON",n[0].sourceJSON),this.set("rasterInfo",t.rasterInfo),await this._updateClipGeometry()}async syncJobHandler(){return this.rasterJobHandler?.updateRasterFunction(this.rasterFunction)}async _updateClipGeometry(){const e=this.rasterFunction.getClippingGeometries()[0];let t=e?.clippingGeometry;if(t&&"inside"===e.clippingType){const{extent:e}=this.rasterInfo,{difference:i,densify:r}=await Promise.all([n.e(31329),n.e(60822)]).then(n.bind(n,60822));let s=r(l.default.fromExtent(e),2*(e.width+e.height)/40);s=(0,h.uk)(s,t.spatialReference),t=i(s,t)}this._clippingGeometry.clear(),t&&this._clippingGeometry.set("0",t)}};(0,i._)([(0,s.MZ)({type:String,json:{write:!0}})],f.prototype,"datasetFormat",void 0),(0,i._)([(0,s.MZ)()],f.prototype,"tileType",void 0),(0,i._)([(0,s.MZ)()],f.prototype,"rasterFunction",void 0),(0,i._)([(0,s.MZ)()],f.prototype,"primaryRasters",void 0),f=(0,i._)([(0,a.$)("esri.layers.support.rasterDatasets.FunctionRaster")],f);const m=f},86981:(e,t,n)=>{n.d(t,{A:()=>D});var i=n(93800),r=n(23060),s=n(74719),a=n(19455),l=n(50925),o=n(49959),u=n(9240),c=n(48602),h=n(80556),d=(n(21265),n(14746),n(75269)),f=n(12560),m=n(75400),p=n(93321),g=n(65073),y=n(75238),x=n(73848),b=n(29275),v=n(286),w=n(4126),_=n(74706),k=n(62661),I=n(82518),S=n(51971),R=n(50396),M=n(90801),T=n(21543);let F=0,N=class extends a.A{constructor(){super(...arguments),this._tileFetchQueue=new u.QueueProcessor({concurrency:32,process:(e,t)=>this._fetchRawTile(e.pyramidLevel,e.row,e.col,{...e.options,signal:t})}),this.datasetName=null,this.datasetFormat=null,this.hasUniqueSourceStorageInfo=!0,this.rasterInfo=null,this.ioConfig={sampling:"closest"}}normalizeCtorArgs(e){return e?.ioConfig&&(e={...e,ioConfig:{resolution:null,bandIds:null,sampling:"closest",tileInfo:w.default.create(),...e.ioConfig}}),e}get _isGlobalWrappableSource(){const{rasterInfo:e}=this,t=(0,M.FT)(e.spatialReference);return null!=t&&e.extent.width>=t/2}get _hasNoneOrGCSShiftTransform(){const{transform:e}=this.rasterInfo;return null==e||"gcs-shift"===e.type}set rasterJobHandler(e){this._set("rasterJobHandler",e),"Function"===this.datasetFormat&&this.primaryRasters?.rasters?.forEach((t=>t.rasterJobHandler=e))}get rasterId(){return this.url||"rasterId-"+F++}set url(e){this._set("url",(0,g.Jf)(e,l.A.getLogger(this)))}async open(e){return this._openPromise??=(0,M.Hh)().then((()=>this._open(e))),this._openPromise}async fetchTile(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r=i.tileInfo||this.rasterInfo.storageInfo.tileInfo,s=this.getTileExtentFromTileInfo(e,t,n,r);return i={noClip:!0,...i},this.fetchPixels(s,r.size[0],r.size[1],i)}async identify(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:{};e=(0,h.PZ)(m.default,e).clone().normalize();const{multidimensionalDefinition:n,timeExtent:i}=t,{rasterInfo:r}=this,{hasMultidimensionalTranspose:s,multidimensionalInfo:a}=r;let{transposedVariableName:l}=t;const o=null!=a&&s&&(null!=i||(0,_.DY)(n));o&&!l&&(l=null!=n&&n.length>0?n[0].variableName??void 0:a.variables[0].name,t={...t,transposedVariableName:l}),t=this._getRequestOptionsWithSliceId(t);const{spatialReference:u,extent:c}=r,{datumTransformation:d}=t;let p=(0,M._I)(e,u,d);if(!c.intersects(p))return{location:p,value:null};if(null!=r.transform){const e=r.transform.inverseTransform(p);if(!r.nativeExtent.intersects(e))return{location:e,value:null};p=e}let g=0;const y=null!=l&&null!=a&&r.hasMultidimensionalTranspose;if("Function"===this.datasetFormat){const e=this.primaryRasters.rasters[0];if(y)return e.identify(p,t);const{pixelSize:i}=r,s=3,a=i.x*s/2,l=i.y*s/2,o=new f.default({xmin:p.x-a,xmax:p.x+a,ymin:p.y-l,ymax:p.y+l,spatialReference:u}),c={interpolation:"nearest",multidimensionalDefinition:n,sliceId:t.sliceId},{pixelBlock:h}=await e.fetchPixels(o,s,s,c),{pixelBlock:d}=await this.fetchPixels(o,s,s,c);if(null==h)return{location:p,value:null};const m=Math.floor(s*s*.5),g=!h.mask||h.mask[m]?h.pixels.map((e=>e[m])):null;let x;return null!=d&&(x=!d.mask||d.mask[m]?d.pixels.map((e=>e[m])):void 0),{location:p,value:g,processedValue:x,pyramidLevel:0}}if(!y)if(t.srcResolution)g=(0,M.t$)(t.srcResolution,r,this.ioConfig.sampling).pyramidLevel;else if(g=await this.computeBestPyramidLevelForLocation(e,t),null==g)return{location:p,value:null};const x=this.identifyPixelLocation(p,g,null,y);if(null===x)return{location:p,value:null};const{row:b,col:v,rowOffset:w,colOffset:I,blockWidth:S}=x,R=l??t.sliceId,T=(0,k.ph)(this.rasterId,R),F=`${g}/${b}/${v}`;let N=(0,k.gd)(T,null,F);null==N&&(N=this.fetchRawTile(g,b,v,t),(0,k.no)(T,null,F,N));const D=await N;if(!D?.pixels?.length)return{location:p,value:null};const C=w*S+I;return this._processIdentifyResult(D,{srcLocation:p,position:C,pyramidLevel:g,useTransposedTile:!!y,requestSomeSlices:o,identifyOptions:t})}async fetchPixels(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};e=(0,M.Ps)(e),i=this._getRequestOptionsWithSliceId(i);const{_hasNoneOrGCSShiftTransform:r}=this;if(i.requestRawData&&r)return this._fetchPixels(e,t,n,i);const s=(0,M.FT)(e.spatialReference),a=(0,M.OM)(e);if(null==s||0===a||1===a&&this._isGlobalWrappableSource&&r)return this._fetchPixels(e,t,n,i);if(a>=3)return{extent:e,pixelBlock:null};const l=[],{xmin:o,xmax:u}=e,c=Math.round(s/(u-o)*t),h=c-Math.round((s/2-o)/(u-o)*t);let d=0;const m=[];for(let x=0;x<=a;x++){const r=new f.default({xmin:0===x?o:-s/2,xmax:x===a?u-s*x:s/2,ymin:e.ymin,ymax:e.ymax,spatialReference:e.spatialReference}),p=0===x?c-h:x===a?t-d:c;d+=p,m.push(p);const g=i.disableWrapAround&&x>0?null:this._fetchPixels(r,p,n,i);l.push(g)}const p=(await Promise.all(l)).map((e=>e?.pixelBlock));let g=null;const y={width:t,height:n};return g=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:p,srcMosaicSize:y,destDimension:null,coefs:null,sampleSpacing:null,interpolation:"nearest",alignmentInfo:null,blockWidths:m},i)).pixelBlock:(0,R.z7)(p,y,{blockWidths:m}),{extent:e,srcExtent:(0,M._l)(e,this.rasterInfo.spatialReference,i.datumTransformation),pixelBlock:g}}async fetchRawPixels(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};t={x:Math.floor(t.x),y:Math.floor(t.y)};const r=await this._fetchRawTiles(e,t,n,i),{nativeExtent:s,nativePixelSize:a,storageInfo:l}=this.rasterInfo,o=2**e,u=a.x*o,c=a.y*o,h=new f.default({xmin:s.xmin+u*t.x,xmax:s.xmin+u*(t.x+n.width-1),ymin:s.ymax-c*(t.y+n.height-1),ymax:s.ymax-c*t.y,spatialReference:s.spatialReference});if(!r)return{extent:h,srcExtent:h,pixelBlock:null};const{pixelBlocks:d,mosaicSize:m}=r;if(1===d.length&&null!=d[0]&&d[0].width===n.width&&d[0].height===n.height)return{extent:h,srcExtent:h,pixelBlock:r.pixelBlocks[0]};const p=e>0?l.pyramidBlockWidth:l.blockWidth,g=e>0?l.pyramidBlockHeight:l.blockHeight,y={x:t.x%p,y:t.y%g};let x;return x=this.rasterJobHandler?(await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:d,srcMosaicSize:m,destDimension:n,clipOffset:y,clipSize:n,coefs:null,sampleSpacing:null,interpolation:i.interpolation,alignmentInfo:null,blockWidths:null},i)).pixelBlock:(0,R.z7)(d,m,{clipOffset:y,clipSize:n}),{extent:h,srcExtent:h,pixelBlock:x}}fetchRawTile(e,t,n,i){throw new s.default("BaseRaster:read-not-implemented","fetchRawTile() is not implemented")}computeExtent(e){return(0,M._l)(this.rasterInfo.extent,e)}decodePixelBlock(e,t){return!this.rasterJobHandler||t.useCanvas?(0,S.D)(e,t):this.rasterJobHandler.decode({data:e,options:t})}async request(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:0;const{customFetchParameters:i}=this.ioConfig,{range:s,query:a,headers:l}=t;n=n??t.retryCount??this.ioConfig.retryCount;const o=s?{Range:`bytes=${s.from}-${s.to}`}:null;try{return await(0,r.default)(e,{...t,query:{...a,...i},headers:{...l,...o}})}catch(u){if(n>0)return n--,this.request(e,t,n);throw u}}getSliceIndex(e){const{multidimensionalInfo:t}=this.rasterInfo;return null==t||null==e||0===e.length?null:(0,_.NG)(e,t)}getTileExtentFromTileInfo(e,t,n,i){const r=i.lodAt(e);return this.getTileExtent({x:r.resolution,y:r.resolution},t,n,i.origin,i.spatialReference,i.size)}updateTileInfo(){const{storageInfo:e,spatialReference:t,extent:n,pixelSize:i}=this.rasterInfo,{pyramidResolutions:r}=e;if(!e.tileInfo){const s=[],a=e.maximumPyramidLevel||0;let l=(i.x+i.y)/2,o=1/.0254*96*l;for(let e=0;e<=a&&(s.unshift(new b.default({level:a-e,resolution:l,scale:o})),e!==a);e++)if(r){const t=(r[e].x+r[e].y)/2;o*=t/l,l=t}else l*=2,o*=2;const u=new m.default({x:n.xmin,y:n.ymax,spatialReference:t});e.tileInfo=new w.default({origin:u,size:[e.blockWidth,e.blockHeight],spatialReference:t,lods:s}),e.isVirtualTileInfo=!0}}createRemoteDatasetStorageInfo(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:512,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:512,i=arguments.length>3?arguments[3]:void 0;const{width:r,height:s,nativeExtent:a,pixelSize:l,spatialReference:o}=e,u=new m.default({x:a.xmin,y:a.ymax,spatialReference:o});null==i&&(i=Math.max(0,Math.round(Math.log(Math.max(r,s))/Math.LN2-8)));const c=this.computeBlockBoundary(a,512,512,{x:a.xmin,y:a.ymax},[l],i);e.storageInfo=new v.A({blockWidth:t,blockHeight:n,pyramidBlockWidth:t,pyramidBlockHeight:n,origin:u,firstPyramidLevel:1,maximumPyramidLevel:i,blockBoundary:c})}async computeBestPyramidLevelForLocation(e){return 0}computeBlockBoundary(e,t,n,i,r){let s=arguments.length>5&&void 0!==arguments[5]?arguments[5]:0,a=arguments.length>6&&void 0!==arguments[6]?arguments[6]:2;if(1===r.length&&s>0){r=[...r];let{x:e,y:t}=r[0];for(let n=0;n<s;n++)e*=a,t*=a,r.push({x:e,y:t})}const l=[],{x:o,y:u}=i;for(let c=0;c<r.length;c++){const{x:i,y:s}=r[c];l.push({minCol:Math.floor((e.xmin-o+.1*i)/t/i),maxCol:Math.floor((e.xmax-o-.1*i)/t/i),minRow:Math.floor((u-e.ymax+.1*s)/n/s),maxRow:Math.floor((u-e.ymin-.1*s)/n/s)})}return l}getPyramidPixelSize(e){const{nativePixelSize:t}=this.rasterInfo,{pyramidResolutions:n,pyramidScalingFactor:i}=this.rasterInfo.storageInfo;if(0===e)return t;if(null!=n&&n.length)return n[e-1];const r=i**e;return{x:t.x*r,y:t.y*r}}identifyPixelLocation(e,t,n,i){const{spatialReference:r,nativeExtent:s,storageInfo:a}=this.rasterInfo,{maximumPyramidLevel:l,origin:o,transposeInfo:u}=a,c=i&&null!=u?u.tileSize[0]:a.blockWidth,h=i&&null!=u?u.tileSize[1]:a.blockHeight,d=(0,M._I)(e,r,n);if(!s.intersects(d))return null;if(t<0||t>l)return null;const f=this.getPyramidPixelSize(t),{x:m,y:p}=f,g=(o.y-d.y)/p/h,y=(d.x-o.x)/m/c,x=Math.min(h-1,Math.floor((g-Math.floor(g))*h)),b=Math.min(c-1,Math.floor((y-Math.floor(y))*c));return{pyramidLevel:t,row:Math.floor(g),col:Math.floor(y),rowOffset:x,colOffset:b,blockWidth:c,srcLocation:d}}getTileExtent(e,t,n,i,r,s){const[a,l]=s,o=i.x+n*a*e.x,u=o+a*e.x,c=i.y-t*l*e.y,h=c-l*e.y;return new f.default({xmin:o,xmax:u,ymin:h,ymax:c,spatialReference:r})}getBlockWidthHeight(e){return{blockWidth:e>0?this.rasterInfo.storageInfo.pyramidBlockWidth:this.rasterInfo.storageInfo.blockWidth,blockHeight:e>0?this.rasterInfo.storageInfo.pyramidBlockHeight:this.rasterInfo.storageInfo.blockHeight}}isBlockOutside(e,t,n){const i=this.rasterInfo.storageInfo.blockBoundary[e];return!i||i.maxRow<t||i.maxCol<n||i.minRow>t||i.minCol>n}updateImageSpaceRasterInfo(e){const{pixelSize:t}=e,{width:n,height:i}=e,r=p.default.WebMercator;e.spatialReference=r,e.extent=e.nativeExtent=new f.default({xmin:-.5,ymax:.5,xmax:n-.5,ymin:.5-i,spatialReference:r}),e.isPseudoSpatialReference=!0,e.transform=null,e.pixelSize=new m.default({x:1,y:1,spatialReference:r});const{extent:s,storageInfo:a}=e;if(a){a.origin=new m.default({x:s.xmin,y:s.ymax,spatialReference:r});const{pyramidResolutions:n,tileInfo:i}=a;if(n&&n.forEach((e=>{e.x/=t.x,e.y/=t.y})),i){i.origin=a.origin;const t=(e.nativePixelSize.x+e.nativePixelSize.y)/2;i.lods.forEach(((e,n)=>{e.resolution=t*2**n,e.scale=96*e.resolution/.0254}))}}}async _fetchPixels(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{},r=(0,M.OM)(e);if(r>=2)return{extent:e,pixelBlock:null};const s=this._getSourceDataInfo(e,t,n,i),{pyramidLevel:a,srcResolution:l,srcExtent:o,srcWidth:u,srcHeight:c,ul:h}=s;if(0===u||0===c)return{extent:e,srcExtent:o,pixelBlock:null};const{rasterInfo:d}=this,f=d.transform,p="gcs-shift"===f?.type,g=null!=(0,M.FT)(e.spatialReference);!p&&g||(r=(0,M.OM)(s.srcExtent,p));const y=await this._fetchRawTiles(a,h,{width:u,height:c,wrapCount:r},i);if(!y)return{extent:e,srcExtent:o,pixelBlock:null};const x=d.storageInfo,b=a>0?x.pyramidBlockWidth:x.blockWidth,v=a>0?x.pyramidBlockHeight:x.blockHeight;let{x:w,y:_}=d.pixelSize;if(a>0){const{pyramidResolutions:e,pyramidScalingFactor:t}=x;if(null!=e&&e[a-1])({x:w,y:_}=e[a-1]);else{const e=t**a;w*=e,_*=e}}const k=d.spatialReference,I=new m.default({x:w,y:_,spatialReference:k}),S=b===u&&v===c&&h.x%b==0&&h.y%v==0,F=new m.default({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference}),N=!e.spatialReference.equals(k),D=k.isGeographic?1e-9:1e-4,{datumTransformation:C}=i;if(!N&&S&&1===y.pixelBlocks.length&&b===t&&v===n&&function(e,t,n){return Math.abs(e.x-t.x)<n&&Math.abs(e.y-t.y)<n}(l,F,D))return{extent:e,srcExtent:o,srcTilePixelSize:I,pixelBlock:y.pixelBlocks[0]};const P=g&&null!=(0,M.FT)(o.spatialReference)&&this._hasNoneOrGCSShiftTransform,B=i.requestProjectedLocalDirections&&this.rasterInfo.dataType.startsWith("vector");B&&!this.rasterJobHandler&&await(0,M.Hh)();const J=this.rasterJobHandler?await this.rasterJobHandler.getProjectionOffsetGrid({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:F.toJSON(),datumTransformation:C,rasterTransform:f,hasWrapAround:r>0||P,isAdaptive:!1!==this.ioConfig.optimizeProjectionAccuracy,includeGCSGrid:B},i):(0,M.l0)({projectedExtent:e,srcBufferExtent:y.extent,pixelSize:F,datumTransformation:C,rasterTransform:f,hasWrapAround:r>0||P,isAdaptive:!1,includeGCSGrid:B});let O;const z=!i.requestRawData,A={rows:J.spacing[0],cols:J.spacing[1]},E=this._hasNoneOrGCSShiftTransform?this._getRasterTileAlignmentInfo(a,y.extent.xmin):void 0,{pixelBlocks:H,mosaicSize:V,isPartiallyFilled:q}=y;let W=null;if(this.rasterJobHandler){const e=await this.rasterJobHandler.mosaicAndTransform({srcPixelBlocks:H,srcMosaicSize:V,destDimension:z?{width:t,height:n}:null,coefs:z?J.coefficients:null,sampleSpacing:z?A:null,projectDirections:B,gcsGrid:B?J.gcsGrid:null,isUV:"vector-uv"===this.rasterInfo.dataType,interpolation:i.interpolation,alignmentInfo:E,blockWidths:null},i);({pixelBlock:O,localNorthDirections:W}=e)}else{const e=(0,R.z7)(H,V,{alignmentInfo:E});O=z?(0,R.$i)(e,{width:t,height:n},J.coefficients,A,i.interpolation):e,B&&J.gcsGrid&&(W=(0,R.QF)({width:t,height:n},J.gcsGrid),O=(0,T.Y2)(O,this.rasterInfo.dataType,W))}return i.requestRawData||B?{extent:e,srcExtent:o,srcTilePixelSize:I,pixelBlock:O,transformGrid:J,localNorthDirections:W,isPartiallyFilled:q}:{extent:e,srcExtent:o,srcTilePixelSize:I,pixelBlock:O}}async _fetchRawTiles(e,t,n,i){const{origin:r,blockBoundary:s}=this.rasterInfo.storageInfo,{blockWidth:a,blockHeight:l}=this.getBlockWidthHeight(e);let{x:o,y:u}=t,{width:c,height:h,wrapCount:d}=n;const m=this._getRasterTileAlignmentInfo(e,0);i.buffer&&(o-=i.buffer.cols,u-=i.buffer.rows,c+=2*i.buffer.cols,h+=2*i.buffer.rows);let p=0,g=0,y=0;d&&null!=m&&(({worldColumnCountFromOrigin:g,originColumnOffset:y,rightPadding:p}=m),g*m.blockWidth-p>=o+c&&(p=0));const x=Math.floor(o/a),b=Math.floor(u/l),v=Math.floor((o+c+p-1)/a),w=Math.floor((u+h+p-1)/l),_=s[e];if(!_)return null;const{minRow:k,minCol:I,maxCol:S,maxRow:R}=_;if(0===d&&(w<k||v<I||b>R||x>S))return null;const M=new Array;let T=!1;const F=null==this.ioConfig.allowPartialFill?i.allowPartialFill:this.ioConfig.allowPartialFill;for(let f=b;f<=w;f++)for(let t=x;t<=v;t++){let n=t;if(!i.disableWrapAround&&d&&null!=m&&g<=t&&(n=t-g-y),f>=k&&n>=I&&R>=f&&S>=n){const t=this._tileFetchQueue.push({pyramidLevel:e,row:f,col:n,options:i},{signal:i.signal});F?M.push(new Promise((e=>{t.then((t=>e(t))).catch((()=>{T=!0,e(null)}))}))):M.push(t)}else M.push(Promise.resolve(null))}if(0===M.length)return null;const N=await Promise.all(M),D={height:(w-b+1)*l,width:(v-x+1)*a},{spatialReference:C}=this.rasterInfo,P=this.getPyramidPixelSize(e),{x:B,y:J}=P;return{extent:new f.default({xmin:r.x+x*a*B,xmax:r.x+(v+1)*a*B,ymin:r.y-(w+1)*l*J,ymax:r.y-b*l*J,spatialReference:C}),pixelBlocks:N,mosaicSize:D,isPartiallyFilled:T}}_fetchRawTile(e,t,n,i){const r=this.rasterInfo.storageInfo.blockBoundary[e];if(!r)return Promise.resolve(null);const{minRow:s,minCol:a,maxCol:l,maxRow:u}=r;if(t<s||n<a||t>u||n>l)return Promise.resolve(null);const c=(0,k.ph)(this.rasterId,i.sliceId),h=`${e}/${t}/${n}`;let d=(0,k.gd)(c,i.registryId,h);if(null==d){const r=new AbortController;d=this.fetchRawTile(e,t,n,{...i,signal:r.signal}),(0,k.no)(c,i.registryId,h,d,r),d.catch((()=>(0,k.zo)(c,i.registryId,h)))}return i.signal&&(0,o.onAbort)(i,(()=>{(0,k.jX)(c,i.registryId,h)})),d}_computeMagDirValues(e){const{bandCount:t,dataType:n}=this.rasterInfo;if((2!==t||"vector-magdir"!==n)&&"vector-uv"!==n||2!==e?.length||!e[0]?.length)return null;const i=e[0].length;if("vector-magdir"===n){const t=e[1].map((e=>(e+360)%360));return[e[0],t]}const[r,s]=e,a=[],l=[];for(let o=0;o<i;o++){const[e,t]=(0,T.Lu)([r[o],s[o]]);a.push(e),l.push(t)}return[a,l]}_getRasterTileAlignmentInfo(e,t){return null==this._rasterTileAlignmentInfo&&(this._rasterTileAlignmentInfo=(0,M.DO)(this.rasterInfo)),null==this._rasterTileAlignmentInfo.pyramidsInfo?null:{startX:t,halfWorldWidth:this._rasterTileAlignmentInfo.halfWorldWidth,hasGCSSShiftTransform:this._rasterTileAlignmentInfo.hasGCSSShiftTransform,...this._rasterTileAlignmentInfo.pyramidsInfo[e]}}_getSourceDataInfo(e,t,n){let i=arguments.length>3&&void 0!==arguments[3]?arguments[3]:{};const r={datumTransformation:i.datumTransformation,pyramidLevel:0,pyramidResolution:null,srcExtent:null,srcHeight:0,srcResolution:null,srcWidth:0,ul:{x:0,y:0}};i.srcResolution&&(r.srcResolution=i.srcResolution,this._updateSourceDataInfo(e,r));const s=this.rasterInfo.storageInfo.maximumPyramidLevel||0,{srcWidth:a,srcHeight:l,pyramidLevel:o}=r,u=a/t,c=l/n,h=o<s&&u*c>=16,d=o===s&&this._requireTooManySrcTiles(a,l,t,n);if(h||d||0===a||0===l){const a=new m.default({x:(e.xmax-e.xmin)/t,y:(e.ymax-e.ymin)/n,spatialReference:e.spatialReference});let l=(0,M.Wo)(a,this.rasterInfo.spatialReference,e,r.datumTransformation);const d=!l||i.srcResolution&&l.x+l.y<i.srcResolution.x+i.srcResolution.y;if(h&&i.srcResolution&&d){const e=Math.round(Math.log(Math.max(u,c))/Math.LN2)-1;if(s-o+3>=e){const t=2**e;l={x:i.srcResolution.x*t,y:i.srcResolution.y*t}}}l&&(r.srcResolution=l,this._updateSourceDataInfo(e,r))}return this._requireTooManySrcTiles(r.srcWidth,r.srcHeight,t,n)&&(r.srcWidth=0,r.srcHeight=0),r}_requireTooManySrcTiles(e,t,n,i){const{tileInfo:r}=this.rasterInfo.storageInfo,s=e/n,a=t/i;return Math.ceil(e/r.size[0])*Math.ceil(t/r.size[1])>=256*Math.max(1,(n+i)/1024)||s>8||a>8}_updateSourceDataInfo(e,t){t.srcWidth=0,t.srcHeight=0;const{rasterInfo:n}=this,i=n.spatialReference,{srcResolution:r,datumTransformation:s}=t,{pyramidLevel:a,pyramidResolution:l,excessiveReading:o}=(0,M.t$)(r,n,this.ioConfig.sampling);if(o)return;let u=t.srcExtent||(0,M._l)(e,i,s);if(null==u)return;const c=n.transform;c&&(u=c.inverseTransform(u)),t.srcExtent=u;const{x:h,y:d}=n.storageInfo.origin,f=Math.floor((u.xmin-h)/l.x+.1),m=Math.floor((d-u.ymax)/l.y+.1),p=Math.floor((u.xmax-h)/l.x-.1),g=Math.floor((d-u.ymin)/l.y-.1),y=u.width<.1*l.x?0:p-f+1,x=u.height<.1*l.y?0:g-m+1;t.pyramidLevel=a,t.pyramidResolution=l,t.srcWidth=y,t.srcHeight=x,t.ul={x:f,y:m}}_getRequestOptionsWithSliceId(e){return null!=this.rasterInfo.multidimensionalInfo&&null==e.sliceId&&(e={...e,sliceId:this.getSliceIndex(e.multidimensionalDefinition)}),e}_processIdentifyResult(e,t){const{srcLocation:n,position:i,pyramidLevel:r,useTransposedTile:s}=t,a=e.pixels[0].length/e.width/e.height;if(e.mask&&!e.mask[i])return{location:n,value:null};const{multidimensionalInfo:l}=this.rasterInfo;if(null==l||!s){const t=e.pixels.map((e=>e[i])),s={location:n,value:t,pyramidLevel:r},a=this._computeMagDirValues(t.map((e=>[e])));return a?.length&&(s.magdirValue=a.map((e=>e[0]))),s}let o=e.pixels.map((e=>e.slice(i*a,i*a+a))),u=this._computeMagDirValues(o);const{requestSomeSlices:c,identifyOptions:h}=t;let d=(0,_.QW)(l,h.transposedVariableName);if(c){const e=(0,_.xx)(d,h.multidimensionalDefinition,h.timeExtent);o=o.map((t=>e.map((e=>t[e])))),u=u?.map((t=>e.map((e=>t[e])))),d=e.map((e=>d[e]))}const f=e.noDataValues||this.rasterInfo.noDataValue,m={pixels:o,pixelType:e.pixelType};let p;return null!=f&&((0,I.Sp)(m,f),p=m.mask),{location:n,value:null,dataSeries:d.map(((e,t)=>{const n={value:0===p?.[t]?null:o.map((e=>e[t])),multidimensionalDefinition:e.multidimensionalDefinition.map((e=>new x.default({...e,isSlice:!0})))};return u?.length&&(n.magdirValue=[u[0][t],u[1][t]]),n})),pyramidLevel:r}}};(0,i._)([(0,c.MZ)()],N.prototype,"_rasterTileAlignmentInfo",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"_tileFetchQueue",void 0),(0,i._)([(0,c.MZ)({readOnly:!0})],N.prototype,"_isGlobalWrappableSource",null),(0,i._)([(0,c.MZ)({readOnly:!0})],N.prototype,"_hasNoneOrGCSShiftTransform",null),(0,i._)([(0,c.MZ)()],N.prototype,"_openPromise",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"rasterJobHandler",null),(0,i._)([(0,c.MZ)({readOnly:!0})],N.prototype,"rasterId",null),(0,i._)([(0,c.MZ)(y.OZ)],N.prototype,"url",null),(0,i._)([(0,c.MZ)({type:String,json:{write:!0}})],N.prototype,"datasetName",void 0),(0,i._)([(0,c.MZ)({type:String,json:{write:!0}})],N.prototype,"datasetFormat",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"hasUniqueSourceStorageInfo",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"rasterInfo",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"ioConfig",void 0),(0,i._)([(0,c.MZ)()],N.prototype,"sourceJSON",void 0),N=(0,i._)([(0,d.$)("esri.layers.support.rasterDatasets.BaseRaster")],N);const D=N}}]);