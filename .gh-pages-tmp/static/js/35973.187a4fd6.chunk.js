"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[35973],{35973:(o,t,e)=>{e.r(t),e.d(t,{default:()=>x});var r=e(93800),s=e(88102),i=e(85715),n=e(89129),l=e(40736),p=e(19455),a=e(64682),c=e(48602),h=(e(21265),e(50925),e(14746),e(75269)),u=e(80556);let y=class extends(i.A.ClonableMixin(p.A)){constructor(){super(...arguments),this.color=null,this.position=0}};(0,r._)([(0,c.MZ)({type:s.default,json:{type:[u.jz],write:{enabled:!0,isRequired:!0}}})],y.prototype,"color",void 0),(0,r._)([(0,c.MZ)({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],y.prototype,"position",void 0),y=(0,r._)([(0,h.$)("esri.layers.voxel.VoxelColorStop")],y);const d=y;let f=class extends(i.A.ClonableMixin(p.A)){constructor(){super(...arguments),this.opacity=1,this.position=0}};(0,r._)([(0,c.MZ)({type:Number,json:{name:"alpha",write:{enabled:!0,isRequired:!0}}})],f.prototype,"opacity",void 0),(0,r._)([(0,c.MZ)({type:Number,json:{write:{enabled:!0,isRequired:!0}}})],f.prototype,"position",void 0),f=(0,r._)([(0,h.$)("esri.layers.voxel.VoxelOpacityStop")],f);const g=f;let b=class extends(i.A.ClonableMixin(p.A)){constructor(){super(...arguments),this.enabled=!1,this.range=null}};(0,r._)([(0,c.MZ)({type:Boolean,json:{default:!1,write:!0}})],b.prototype,"enabled",void 0),(0,r._)([(0,c.MZ)({type:[Number],json:{write:{isRequired:!0}}})],b.prototype,"range",void 0),b=(0,r._)([(0,h.$)("esri.layers.voxel.VoxelRangeFilter")],b);const S=b;var _,M;(M=_||(_={}))[M.Color=1]="Color",M[M.Alpha=2]="Alpha",M[M.Both=3]="Both";let v=class extends(i.A.ClonableMixin(p.A)){constructor(o){super(o),this.interpolation=null,this.stretchRange=null,this.rangeFilter=null,this._colorMapSize=256,this.colorStops=new(n.default.ofType(d)),this.opacityStops=new(n.default.ofType(g))}set colorStops(o){this._set("colorStops",(0,l.V)(o,this._get("colorStops"),n.default.ofType(d)))}set opacityStops(o){this._set("opacityStops",(0,l.V)(o,this._get("opacityStops"),n.default.ofType(g)))}getPreviousNext(o,t,e){let r=o;for(;--r>0&&t[r].type!==e&&t[r].type!==_.Both;);let s=o;const i=t.length;for(;++s<i&&t[s].type!==e&&t[s].type!==_.Both;);return[r,s]}get rasterizedTransferFunction(){const o=[];if(this.colorStops.length<2)return o;const t=[],e=[];for(const s of this.colorStops){if(!s.color)return o;e.push({color:{r:s.color.r,g:s.color.g,b:s.color.b,a:Math.round(255*(1-s.color.a))},position:s.position,type:_.Color})}if(0===this.opacityStops.length)for(const s of e)t.push({color:s.color,position:s.position});else{for(const t of this.opacityStops){const o=(0,a.qE)(t.position,0,1),r=Math.round(255*(0,a.qE)(1-t.opacity,0,1));let s=!1;for(const t of e)if(t.type===_.Color&&Math.abs(t.position-o)<1e-5){t.color.a=r,t.type=_.Both,s=!0;break}s||e.push({color:{r:0,g:0,b:0,a:r},position:t.position,type:_.Alpha})}e.sort(((o,t)=>o.position<t.position?-1:1));const o=e.length;for(let t=0;t<o;++t){const r=e[t];if(r.type!==_.Both)if(r.type===_.Color){const[s,i]=this.getPreviousNext(t,e,_.Alpha);if(-1!==s&&i!==o){const o=(r.position-e[s].position)/(e[i].position-e[s].position);r.color.a=Math.round((0,a.Cc)(e[s].color.a,e[i].color.a,o))}else r.color.a=-1!==s?e[s].color.a:e[i].color.a}else{const[s,i]=this.getPreviousNext(t,e,_.Color);if(-1!==s&&i!==o){const o=(r.position-e[s].position)/(e[i].position-e[s].position),t=e[s].color,n=e[i].color;C.forEach((e=>{r.color[e]=Math.round((0,a.Cc)(t[e],n[e],o))}))}else-1!==s?C.forEach((o=>{r.color[o]=e[s].color[o]})):C.forEach((o=>{r.color[o]=e[i].color[o]}))}}for(const r of e)t.push({color:r.color,position:r.position})}t[0].position=0,t[t.length-1].position=1;let r=0,i=1;for(let n=0;n<this._colorMapSize;++n){const e=n/this._colorMapSize;for(;e>t[i].position;)r=i++;const l=(e-t[r].position)/(t[i].position-t[r].position),p=t[r].color,c=t[i].color,h=new s.default;C.forEach((o=>{h[o]=Math.round((0,a.Cc)(p[o],c[o],l))})),h.a=(0,a.qE)(1-(0,a.Cc)(p.a,c.a,l)/255,0,1),o.push(h)}return o}getColorForContinuousDataValue(o,t){const e=this.rasterizedTransferFunction;if(this.colorStops.length<2||!Array.isArray(this.stretchRange)||this.stretchRange.length<2||e.length<256)return null;let r=this.stretchRange[0],s=this.stretchRange[1];if(r>s){const o=r;r=s,s=o}o=(0,a.qE)(o,r,s);const i=e[Math.round((o-r)/(s-r)*(this._colorMapSize-1))].clone();return t||(i.a=1),i}};(0,r._)([(0,c.MZ)({type:["linear","nearest"],json:{write:!0}})],v.prototype,"interpolation",void 0),(0,r._)([(0,c.MZ)({type:[Number],json:{write:{enabled:!0,isRequired:!0}}})],v.prototype,"stretchRange",void 0),(0,r._)([(0,c.MZ)({type:n.default.ofType(d),json:{write:{enabled:!0,overridePolicy(){return{enabled:!!this.colorStops&&this.colorStops.length>0}}}}})],v.prototype,"colorStops",null),(0,r._)([(0,c.MZ)({type:n.default.ofType(g),json:{read:{source:"alphaStops"},write:{enabled:!0,target:"alphaStops",overridePolicy(){return{enabled:!!this.opacityStops&&this.opacityStops.length>0}}}}})],v.prototype,"opacityStops",null),(0,r._)([(0,c.MZ)({type:S,json:{write:!0}})],v.prototype,"rangeFilter",void 0),(0,r._)([(0,c.MZ)({type:[s.default],clonable:!1,json:{read:!1}})],v.prototype,"rasterizedTransferFunction",null),v=(0,r._)([(0,h.$)("esri.layers.voxel.VoxelTransferFunctionStyle")],v);const x=v,C=["r","g","b"]}}]);