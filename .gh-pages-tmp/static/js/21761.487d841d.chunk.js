"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[21761],{21761:(e,t,n)=>{n.d(t,{P:()=>M});var i=n(93800),o=n(6946),s=n(74719),a=n(50925),r=n(45622),d=n(49959),p=n(14125),l=n(48602),h=(n(21265),n(14746),n(75269)),c=n(12560),m=n(65920),u=n(96913),y=n(70576),f=n(39244),g=n(22209),b=n(30449),w=n(59858),T=n(52453),I=n(53512);let M=class extends o.default{constructor(e){super(e),this._processingCacheUpdatesLookup=new Map,this.knowledgeGraph=null,this.inclusionModeDefinition={generateAllSublayers:!0,namedTypeDefinitions:new Map},this.entityTypeNames=new Set,this.relationshipTypeNames=new Set,this.geographicLookup=new Map,this.sublayerCaches=new Map,this.nodeConnectionsLookup=new Map,this.relationshipConnectionsLookup=new Map,this.memberIdTypeLookup=new Map;const t=new Map;e.knowledgeGraph.dataModel.entityTypes?.forEach((n=>{n.name&&(t.set(n.name,"entity"),this._processingCacheUpdatesLookup.set(n.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.entityTypeNames.add(n.name),n.properties?.forEach((e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(n.name,{name:e.name??"",geometryType:e.geometryType})})))})),e.knowledgeGraph.dataModel.relationshipTypes?.forEach((n=>{n.name&&(t.set(n.name,"relationship"),this._processingCacheUpdatesLookup.set(n.name,[]),e.inclusionModeDefinition&&!e.inclusionModeDefinition?.generateAllSublayers||this.relationshipTypeNames.add(n.name),n.properties?.forEach((e=>{e.geometryType&&"esriGeometryNull"!==e.geometryType&&this.geographicLookup.set(n.name,{name:e.name??"",geometryType:e.geometryType})})))})),e.inclusionModeDefinition?.namedTypeDefinitions.forEach(((n,i)=>{if("entity"===t.get(i))this.entityTypeNames.add(i);else{if("relationship"!==t.get(i))return a.A.getLogger(this).warn(`A named type, ${i}, was in the inclusion list that wasn't in the data model and will be removed`),void e.inclusionModeDefinition?.namedTypeDefinitions.delete(i);this.relationshipTypeNames.add(i)}const o=new Map;n.members?.forEach((e=>{(0,r.tE)(this.memberIdTypeLookup,e.id,(()=>new Set)).add(i);const t=this.getById(e.id);t&&o.set(e.id,t)})),this.sublayerCaches.set(i,o)}))}addToLayer(e){e.forEach((e=>{let{typeName:t,id:n}=e;if(!this.inclusionModeDefinition)throw new s.default("knowledge-graph:layer-data-manager","You cannot add to a layer's exclusion list if it was not created with an exclusion list originally");if(this.inclusionModeDefinition.namedTypeDefinitions.has(t)){if(this.inclusionModeDefinition.namedTypeDefinitions.has(t)){const e=this.inclusionModeDefinition.namedTypeDefinitions.get(t);e.members||(e.members=new Map),e.members.set(n,{id:n}),(0,r.tE)(this.memberIdTypeLookup,n,(()=>new Set)).add(t)}}else{const e=new Map;e.set(n,{id:n}),this.inclusionModeDefinition.namedTypeDefinitions.set(t,{useAllData:!1,members:e}),(0,r.tE)(this.memberIdTypeLookup,n,(()=>new Set)).add(t)}}))}getById(e){return g.A.getInstance().readFromStoreById(e)}async getData(e,t,n){if(t.objectType.name&&this.inclusionModeDefinition?.namedTypeDefinitions&&this.inclusionModeDefinition.namedTypeDefinitions.size>0&&!this.inclusionModeDefinition.namedTypeDefinitions.has(t.objectType.name))return[];let i;if(i=e||new I.default({where:"1=1",outFields:["*"]}),"link-chart"===t.parentCompositeLayer.type){const e=t.parentCompositeLayer,n=this._processingCacheUpdatesLookup.get(t.objectType.name??""),o=i.outFields;o&&1===o.length&&o[0]===f.dr&&"1=1"===i.where||await Promise.all(n??[]);const s=this.sublayerCaches.has(t.objectType.name??"")?Array.from(this.sublayerCaches.get(t.objectType.name)?.values()):[],a=[];return s.forEach((n=>{if(this.relationshipTypeNames.has(t.objectType.name)){n.geometry=e.relationshipLinkChartDiagramLookup.get(n.attributes[t.objectIdField]);const i=this.memberIdTypeLookup.get(n.attributes[f.Cz]),o=this.memberIdTypeLookup.get(n.attributes[f.KQ]),s=this._isEndEntitySpatial(i,n,f.Cz),a=this._isEndEntitySpatial(o,n,f.KQ);n.attributes[f.BL]=Number(s&&a)}else{n.geometry=e.entityLinkChartDiagramLookup.get(n.attributes[t.objectIdField]);const i=this.geographicLookup.get(t.objectType.name);i&&n.attributes[i.name]?n.attributes[f.BL]=1:n.attributes[f.BL]=0}n.attributes[f.T1]=n.geometry,a.push(n)})),a}return this.retrieveDataFromService(i,t,n)}async getConnectedRecordIds(e,t,n){const i=[];let o="";const s=this._getNamedTypeIdMapFromNodeIds(e);if(t&&0!==t?.length){for(const e of t)o=o+e+"|";o=o.slice(0,-1)}const a={},r=[];for(const[l,h]of s){const e=`${l}_ids`;a[e]=h,t&&0!==t?.length?r.push(`MATCH (n:${l}) WHERE id(n) IN $${e} WITH n MATCH (n)-[r:${o}]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`):r.push(`MATCH (n:${l}) WHERE id(n) IN $${e} WITH n MATCH (n)-[r]-(m) RETURN id(r), type(r), id(m), labels(m)[0]`)}if(!r.length)return i;const d=r.join(" UNION "),p=(await(0,w.executeQueryStreaming)(this.knowledgeGraph,new T.default({openCypherQuery:d,bindParameters:a}),{signal:n?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;for(let n=0;n<t.length;n++){const e=t[n];i.push({id:e[0],typeName:e[1]}),i.push({id:e[2],typeName:e[3]})}}return i}async getRelationshipsBetweenNodes(e,t,n){const i=this._getNamedTypeIdMapFromNodeIds(e);if(0===i.size)return[];const o={relationshipExclusionIds:t,possibleConnectionEntityIds:e},s=[];for(const[p,l]of i.entries()){const e=`${p}_ids`;o[e]=l,s.push(`MATCH (n:${p}) WHERE id(n) IN $${e} WITH n MATCH (n)-[r]->(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const a=s.join(" UNION "),r=[],d=(await(0,w.executeQueryStreaming)(this.knowledgeGraph,new T.default({openCypherQuery:a,bindParameters:o}),{signal:n?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await d.read();if(e)break;for(let n=0;n<t.length;n++){const e=t[n];r.push({id:e[0],typeName:e[1]})}}return r}async getRelationshipsFromNodes(e,t,n,i){const o=this._getNamedTypeIdMapFromNodeIds(e);if(0===o.size||0===t.length)return[];const s={relationshipExclusionIds:n,possibleConnectionEntityIds:t},a=[];for(const[h,c]of o.entries()){const e=`${h}_ids`;s[e]=c,a.push(`MATCH (n:${h}) WHERE id(n) IN $${e} WITH n MATCH (n)-[r]-(m) WHERE id(m) IN $possibleConnectionEntityIds AND NOT id(r) IN $relationshipExclusionIds RETURN id(r), type(r)`)}const r=a.join(" UNION "),d=new Map,p=(await(0,w.executeQueryStreaming)(this.knowledgeGraph,new T.default({openCypherQuery:r,bindParameters:s}),{signal:i?.signal})).resultRowsStream.getReader();for(;;){const{done:e,value:t}=await p.read();if(e)break;for(let n=0;n<t.length;n++){const e=t[n];let i=d.get(e[1]);i||(i=new Set,d.set(e[1],i)),i.add(e[0])}}const l=[];for(const[h,c]of d)for(const e of c)l.push({id:e,typeName:h});return l}async refreshCacheContent(e,t,n){let i=!(arguments.length>3&&void 0!==arguments[3])||arguments[3],o=arguments.length>4?arguments[4]:void 0;const a=g.A.getInstance(),p=[],l=new Map,h=new Map;this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&h.set(e.name,e)})),this.knowledgeGraph.dataModel.relationshipTypes?.forEach((e=>{e.name&&h.set(e.name,e)})),e||this.inclusionModeDefinition?e?e.forEach((e=>{if(this.memberIdTypeLookup.has(e))for(const t of this.memberIdTypeLookup.get(e))l.has(t)?l.get(t)?.push(e):l.set(t,[e])})):this.inclusionModeDefinition?.namedTypeDefinitions?.forEach(((e,t)=>{e.useAllData?l.set(t,null):e.members&&e.members.forEach((e=>{l.has(t)&&null!==l.get(t)?l.get(t)?.push(e.id):l.set(t,[e.id])}))})):(this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&l.set(e.name,null)})),this.knowledgeGraph.dataModel.entityTypes?.forEach((e=>{e.name&&l.set(e.name,null)})));for(const[d,c]of l){const e=new Set(c),l=new Promise(((p,l)=>{(async()=>{const p=new Set,l=[];let m,u="",y=!1;if(t||h.get(d)?.properties?.forEach((e=>{e.name&&p.add(e.name)})),n&&this.geographicLookup.has(d)){const e=this.geographicLookup.get(d)?.name;e&&p.add(e)}if(this.entityTypeNames.has(d))u=`MATCH (n:${d}) ${c?"WHERE id(n) IN $ids ":""}return ID(n)`,p.forEach((e=>{u+=`, n.${e}`,l.push(e)}));else{if(!this.relationshipTypeNames.has(d))throw new s.default("knowledge-graph:layer-data-manager",`The graph type of ${d} could not be determined. Was this type set in the KG data model and inclusion definition?`);y=!0,u=`MATCH ()-[n:${d}]->() ${c?"WHERE id(n) IN $ids ":""}return ID(n), id(startNode(n)), id(endNode(n))`,p.forEach((e=>{u+=`, n.${e}`,l.push(e)}))}m=new T.default(c?{openCypherQuery:u,bindParameters:{ids:c}}:{openCypherQuery:u});const g=(await(0,w.executeQueryStreaming)(this.knowledgeGraph,m,{signal:o?.signal})).resultRowsStream.getReader();for(;;){const{done:t,value:n}=await g.read();if(t)break;const o=[];for(let i=0;i<n.length;i++){const t=n[i];let s=0,a=0;const d={properties:{}};for(d.id=t[s],s++,a++,y&&(d.originId=t[s],s++,a++,d.destinationId=t[s],s++,a++,(0,r.tE)(this.nodeConnectionsLookup,d.originId,(()=>new Set)).add(d.id),(0,r.tE)(this.nodeConnectionsLookup,d.destinationId,(()=>new Set)).add(d.id),(0,r.tE)(this.relationshipConnectionsLookup,d.id,(()=>[d.originId,d.destinationId])));s<t.length;s++)d.properties[l[s-a]]=t[s];e.delete(d.id),o.push(d)}const s=a.writeToStore(o,f.dr,this.geographicLookup.get(d)?.name);this.sublayerCaches.has(d)||this.sublayerCaches.set(d,new Map),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.has(d)&&this.inclusionModeDefinition?.namedTypeDefinitions.set(d,{useAllData:!1,members:new Map}),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(d).members&&(this.inclusionModeDefinition.namedTypeDefinitions.get(d).members=new Map);const p=this.sublayerCaches.get(d);s.forEach((e=>{p?.set(e.attributes[f.dr],e),i&&!this.inclusionModeDefinition?.namedTypeDefinitions.get(d).members.has(e.attributes[f.dr])&&(this.inclusionModeDefinition?.namedTypeDefinitions.get(d).members.set(e.attributes[f.dr],{id:e.attributes[f.dr]}),(0,r.tE)(this.memberIdTypeLookup,e.attributes[f.dr],(()=>new Set)).add(d))}))}const b=this.inclusionModeDefinition?.namedTypeDefinitions.get(d);if(b)for(const t of e)b.members?.delete(t)})().then((()=>{p(null)})).catch((e=>{"AbortError"===e.name?p(null):l(e)}))}));p.push(l),this._processingCacheUpdatesLookup.get(d)?.push(l)}if(await Promise.all(p),o?.signal?.aborted)throw(0,d.createAbortError)()}removeFromLayer(e){const t=new Set,n=new Set(e.map((e=>e.id)));for(const i of e)t.add(i.typeName),1===this.memberIdTypeLookup.get(i.id)?.size?this.memberIdTypeLookup.delete(i.id):this.memberIdTypeLookup.get(i.id)?.delete(i.typeName),this.inclusionModeDefinition?.namedTypeDefinitions.forEach(((e,t)=>{t===i.typeName&&e.members?.has(i.id)&&e.members.delete(i.id)}));t.forEach((e=>{this.sublayerCaches.get(e)?.forEach(((t,i)=>{n.has(i)&&this.sublayerCaches.get(e)?.delete(i)}))}))}async retrieveDataFromService(e,t,n){const i=g.A.getInstance(),o=new Set,a=[];let r,d="",l=[];const h="relationship"===t.graphType,I=this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData,M=t.parentCompositeLayer.sublayerIdsCache.get(t.objectType.name);let E=!I&&M?Array.from(M).sort():null;if(this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData)this.inclusionModeDefinition?.namedTypeDefinitions?.get(t.objectType.name)?.useAllData&&null!=e.objectIds&&(E=e.objectIds);else if(null!=e.objectIds&&E&&E.length>0){const t=e.objectIds;e.objectIds=E.filter((e=>t.includes(e)))}else if(null!=e.objectIds)E=e.objectIds;else{if(this.inclusionModeDefinition?.namedTypeDefinitions.has(t.objectType.name)&&(!this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members||this.inclusionModeDefinition.namedTypeDefinitions.get(t.objectType.name)?.members?.size<1))return e.objectIds=[],[];e.objectIds=E}if(null!=e.outFields){const n=e.outFields;n.includes("*")?t.fields.forEach((e=>{o.add(e.name)})):n.forEach((e=>{e!==f.dr&&e!==t.geometryFieldName&&o.add(e)}))}if(null!=e.geometry){const n=e.geometry;let i;const l=t.parentCompositeLayer.dataManager.knowledgeGraph.serviceDefinition,f=l?.spatialReference,g=l?.serviceCapabilities?.geometryCapabilities;let w=g?.geometryMaxBoundingRectangleSizeX,I=g?.geometryMaxBoundingRectangleSizeY;if("point"===n.type){let e=n;e.spatialReference?.isWGS84||(await(0,u.initializeProjection)(e.spatialReference,y.KK),e=(0,u.project)(e,y.KK)),i=new c.default({spatialReference:y.KK,xmin:e.x-1e-4,ymin:e.y-1e-4,xmax:e.x+1e-4,ymax:e.y+1e-4})}else n?.extent?.spatialReference&&!n.spatialReference?.isWGS84?(await(0,u.initializeProjection)(n.extent.spatialReference,y.KK),i=(0,u.project)(n.extent,y.KK)):i=n.extent;if(w&&I&&f){if(4326!==f.wkid){const e=new c.default({spatialReference:f,xmax:w,ymax:I}),t=(0,u.project)(e,y.KK);w=t.xmax,I=t.ymax}if(i.xmax-i.xmin>w)throw new s.default("knowledge-graph:layer-data-manager",`Extent x bounds should be within ${w}\xb0 latitude, limit exceeded`);if(i.ymax-i.ymin>I)throw new s.default("knowledge-graph:layer-data-manager",`Extent y bounds should be within ${I}\xb0 longitude, limit exceeded`)}if(null!=e.where&&"1=1"!==e.where){const n=await(0,p.parseWhereClause)(e.where.toUpperCase(),t.fieldsIndex);t.fields.forEach((e=>{n.fieldNames.includes(e.name)&&o.add(e.name)}))}d=h?`Match ()-[n:${t.objectType.name}]->() WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n), id(startNode(r)), id(endNode(r))`:`Match (n:${t.objectType.name}) WHERE esri.graph.ST_Intersects($param_filter_geom, n.${t.geometryFieldName}) return ID(n)`,t.geometryFieldName&&o.add(t.geometryFieldName),o.forEach((e=>{d+=`, n.${e}`,a.push(e)})),r=new T.default({openCypherQuery:d,bindParameters:{param_filter_geom:new m.default({rings:(0,b.utilsExtentToInBoundsRings)(i)})}})}else{let n="";if(null!=e.where&&"1=1"!==e.where){const i=await(0,p.parseWhereClause)(e.where,t.fieldsIndex);t.fields.forEach((e=>{i.fieldNames.includes(e.name)&&o.add(e.name)}));const s=new Set(["column-reference","string","number","binary-expression"]),a=new Set(["=","<","<=","<>",">",">=","AND","OR","LIKE"]);let r=!1;const d=e=>{if("column-reference"===e.type)return`n.${e.column}`;if("string"===e.type)return`'${e.value}'`;if("number"===e.type)return`${e.value}`;if("binary-expression"===e.type&&s.has(e.left.type)&&s.has(e.right.type)&&a.has(e.operator))return`${d(e.left)} ${e.operator} ${d(e.right)}`;if("binary-expression"===e.type&&"LIKE"===e.operator){let t="";if("function"===e.left.type&&"column-reference"===e.left.args.value[0].type)t+=`lower(n.${e.left.args.value[0].column})`;else{if("column-reference"!==e.left.type)return r=!0,"";t+=`lower(n.${e.left.column})`}if(t+=" CONTAINS (","string"!==e.right.type)return r=!0,"";{let n=e.right.value;"%"===n.charAt(0)&&(n=n.slice(1)),"%"===n.charAt(n.length-1)&&(n=n.slice(0,-1)),t+=`'${n.toLowerCase()}')`}return t}return r=!0,""};n=d(i.parseTree),r&&(n="")}let i="";i=h?`Match ()-[n:${t.objectType.name}]->()`:`Match (n:${t.objectType.name})`;let s=!1;E&&(s=!0,i+=" WHERE ID(n) IN $ids"),n&&(i+=s?" AND":" WHERE",i+=` ${n}`),i+=" return ID(n)",h&&(i+=", id(startNode(n)), id(endNode(n))"),e.returnGeometry&&t.geometryFieldName&&o.add(t.geometryFieldName),o.forEach((e=>{i+=`, n.${e}`,a.push(e)})),r=new T.default(E?{openCypherQuery:i,bindParameters:{ids:E}}:{openCypherQuery:i})}const D=(await(0,w.executeQueryStreaming)(t.parentCompositeLayer.dataManager.knowledgeGraph,r,n)).resultRowsStream.getReader();for(;;){const{done:e,value:n}=await D.read();if(e)break;const o=[];for(let t=0;t<n.length;t++){const e=n[t];let i=0,s=0;const r={properties:{}};for(r.id=e[i],i++,s++,h&&(r.originId=e[i],i++,s++,r.destinationId=e[i],i++,s++);i<e.length;i++)r.properties[a[i-s]]=e[i];o.push(r)}l=l.concat(i.writeToStore(o,f.dr,t.parentCompositeLayer.dataManager.geographicLookup.get(t.objectType.name)?.name))}return l}_isEndEntitySpatial(e,t,n){for(const i of e??[])if(this.entityTypeNames.has(i)){const e=this.geographicLookup.get(i),o=e&&this.sublayerCaches.get(i)?.get(t.attributes[n]);if(e&&o?.attributes[e.name])return!0}return!1}_getNamedTypeIdMapFromNodeIds(e){const t=new Map;return e.forEach((e=>{if(this.memberIdTypeLookup.has(e))for(const n of this.memberIdTypeLookup.get(e)){if(!this.entityTypeNames.has(n))return;t.has(n)?t.get(n)?.push(e):t.set(n,[e])}})),t}};(0,i._)([(0,l.MZ)()],M.prototype,"knowledgeGraph",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"inclusionModeDefinition",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"entityTypeNames",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"relationshipTypeNames",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"geographicLookup",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"sublayerCaches",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"nodeConnectionsLookup",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"relationshipConnectionsLookup",void 0),(0,i._)([(0,l.MZ)()],M.prototype,"memberIdTypeLookup",void 0),M=(0,i._)([(0,h.$)("esri.layers.knowledgeGraph.KnowledgeGraphLayerDataManager")],M)}}]);