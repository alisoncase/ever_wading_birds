"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[3885,26266,46657,71028],{26266:(e,t,n)=>{n.r(t),n.d(t,{InverseGeodeticSolverResult:()=>y,directGeodeticSolver:()=>b,geodesicAreas:()=>m,geodesicCompatibleSpatialReference:()=>z,geodesicDensify:()=>M,geodesicDistance:()=>R,geodesicLengths:()=>w,inverseGeodeticSolver:()=>_,isSupported:()=>v,pointFromDistance:()=>E});var i=n(74719),a=n(84190),s=n(80556),o=n(75400),r=n(65920),l=n(54824),c=n(93321),u=n(64226),h=n(70576);function p(e){if(!e)return null;const t=e.wkid;if(t)return u.uw[t];const n=e.wkt2??e.wkt;return n?function(e){const t=u._f.exec(e);if(!t||2!==t.length)return null;const n=t[1].split(",");if(!n||n.length<3)return null;const i=parseFloat(n[1]),a=parseFloat(n[2]);return isNaN(i)||isNaN(a)?null:{a:i,f:0===a?0:1/a}}(n):null}function f(e){const t=p(e);if(function(e){return null!=e&&"b"in e&&"eSq"in e&&"radius"in e}(t))return t;const n=t.a*(1-t.f);return Object.assign(t,{b:n,eSq:1-(n/t.a)**2,radius:(2*t.a+n)/3,densificationRatio:1e4/((2*t.a+n)/3)})}function d(e){return null!=e&&e<0?e+360:e}function g(e,t,n){const{a:i,eSq:a}=f(n),s=Math.sqrt(a),o=Math.sin(t[1]*u.eh),r=i*t[0]*u.eh;let l;return l=a>0?i*((1-a)*(o/(1-a*(o*o))-1/(2*s)*Math.log((1-s*o)/(1+s*o))))*.5:i*o,e[0]=r,e[1]=l,e}function v(e){return(0,h.EA)(e)&&!!p(e)}function m(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"square-meters";if(e.some((e=>!v(e.spatialReference))))throw new i.default("geodesic-areas:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const t=e[i],a=t.spatialReference,{radius:s,densificationRatio:o}=f(a),r=s*o;n.push(M(t,r))}const s=[],o=[0,0],r=[0,0];for(let i=0;i<n.length;i++){const{rings:e,spatialReference:l}=n[i];let c=0;for(let t=0;t<e.length;t++){const n=e[t];g(o,n[0],l),g(r,n[n.length-1],l);let i=r[0]*o[1]-o[0]*r[1];for(let e=0;e<n.length-1;e++)g(o,n[e+1],l),g(r,n[e],l),i+=r[0]*o[1]-o[0]*r[1];c+=i}c=(0,a.oU)(c,"square-meters",t),s.push(c/-2)}return s}function w(e){let t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:"meters";if(!e)throw new i.default("geodesic-lengths:invalid-geometries","the input geometries type is not supported");if(e.some((e=>!v(e.spatialReference))))throw new i.default("geodesic-lengths:invalid-spatial-reference","the input geometries spatial reference is not supported");const n=[];for(let i=0;i<e.length;i++){const s=e[i],{spatialReference:o}=s,r="polyline"===s.type?s.paths:s.rings;let l=0;for(let e=0;e<r.length;e++){const t=r[e];let n=0;for(let e=1;e<t.length;e++){const i=t[e-1][0],a=t[e][0],s=t[e-1][1],r=t[e][1];if(s!==r||i!==a){const e=new y;_(e,[i,s],[a,r],o),n+=e.distance}}l+=n}l=(0,a.oU)(l,"meters",t),n.push(l)}return n}function M(e,t){if("polyline"!==e.type&&"polygon"!==e.type)throw new i.default("geodesic-densify:invalid-geometry","the input geometry is neither polyline nor polygon");const{spatialReference:n}=e;if(!v(n))throw new i.default("geodesic-densify:invalid-spatial-reference","the input geometry spatial reference is not supported");const a="polyline"===e.type?e.paths:e.rings,o=[],u=[0,0],h=new y;for(const i of a){const e=[];o.push(e),e.push([i[0][0],i[0][1]]);let a,s,r=i[0][0],l=i[0][1];for(let o=0;o<i.length-1;o++){if(a=i[o+1][0],s=i[o+1][1],r===a&&l===s)continue;const c=[r,l];_(h,[r,l],[a,s],n);const{azimuth:p,distance:f}=h,d=f/t;if(d>1){for(let i=1;i<=d-1;i++)b(u,c,p,i*t,n),e.push(u.slice());b(u,c,p,(f+Math.floor(d-1)*t)/2,n),e.push(u.slice())}b(u,c,p,f,n),e.push(u.slice()),r=u[0],l=u[1]}}const p=(0,s.PZ)(c.default,n);return"polyline"===e.type?new l.default({paths:o,spatialReference:p}):new r.default({rings:o,spatialReference:p})}class y{constructor(){let e=arguments.length>0&&void 0!==arguments[0]?arguments[0]:0,t=arguments.length>1&&void 0!==arguments[1]?arguments[1]:void 0,n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:void 0;this.distance=e,this.azimuth=t,this.reverseAzimuth=n}}function b(e,t,n,i,a){const s=t[0],o=t[1],r=s*u.eh,l=o*u.eh,c=(n??0)*u.eh,{a:h,b:p,f:d}=f(a),g=Math.sin(c),v=Math.cos(c),m=(1-d)*Math.tan(l),w=1/Math.sqrt(1+m*m),M=m*w,y=Math.atan2(m,v),b=w*g,_=b*b,R=1-_,E=R*(h*h-p*p)/(p*p),z=1+E/16384*(4096+E*(E*(320-175*E)-768)),q=E/1024*(256+E*(E*(74-47*E)-128));let D,S,I,k=i/(p*z),x=2*Math.PI;for(;Math.abs(k-x)>1e-12;)I=Math.cos(2*y+k),D=Math.sin(k),S=Math.cos(k),x=k,k=i/(p*z)+q*D*(I+q/4*(S*(2*I*I-1)-q/6*I*(4*D*D-3)*(4*I*I-3)));const A=M*D-w*S*v,L=Math.atan2(M*S+w*D*v,(1-d)*Math.sqrt(_+A*A)),P=d/16*R*(4+d*(4-3*R)),N=Math.atan2(D*g,w*S-M*D*v)-(1-P)*d*b*(k+P*D*(I+P*S*(2*I*I-1)));return e[0]=(r+N)/u.eh,e[1]=L/u.eh,e}function _(e,t,n,i){const a=t[0]*u.eh,s=t[1]*u.eh,o=n[0]*u.eh,r=n[1]*u.eh,{a:l,b:c,f:h,radius:p}=f(i),d=o-a,g=Math.atan((1-h)*Math.tan(s)),v=Math.atan((1-h)*Math.tan(r)),m=Math.sin(g),w=Math.cos(g),M=Math.sin(v),y=Math.cos(v);let b,_,R,E,z,q,D,S,I,k,x=1e3,A=d;do{if(D=Math.sin(A),S=Math.cos(A),R=Math.sqrt(y*D*(y*D)+(w*M-m*y*S)*(w*M-m*y*S)),0===R)return e.distance=0,e.azimuth=void 0,e.reverseAzimuth=void 0,e;z=m*M+w*y*S,q=Math.atan2(R,z),I=w*y*D/R,_=1-I*I,E=z-2*m*M/_,isNaN(E)&&(E=0),k=h/16*_*(4+h*(4-3*_)),b=A,A=d+(1-k)*h*I*(q+k*R*(E+k*z*(2*E*E-1)))}while(Math.abs(A-b)>1e-12&&--x>0);if(0===x){const t=p,n=Math.acos(Math.sin(s)*Math.sin(r)+Math.cos(s)*Math.cos(r)*Math.cos(o-a))*t,i=o-a,l=Math.sin(i)*Math.cos(r),c=Math.cos(s)*Math.sin(r)-Math.sin(s)*Math.cos(r)*Math.cos(i),h=Math.atan2(l,c);return e.azimuth=h/u.eh,e.distance=n,e.reverseAzimuth=void 0,e}const L=_*(l*l-c*c)/(c*c),P=L/1024*(256+L*(L*(74-47*L)-128)),N=c*(1+L/16384*(4096+L*(L*(320-175*L)-768)))*(q-P*R*(E+P/4*(z*(2*E*E-1)-P/6*E*(4*R*R-3)*(4*E*E-3)))),Z=Math.atan2(y*Math.sin(A),w*M-m*y*Math.cos(A)),G=Math.atan2(w*Math.sin(A),w*M*Math.cos(A)-m*y);return e.azimuth=Z/u.eh,e.distance=N,e.reverseAzimuth=G/u.eh,e}function R(e,t){let n=arguments.length>2&&void 0!==arguments[2]?arguments[2]:"meters";if(!e||!t)throw new i.default("geodesic-distance:missing-parameters","one or both input parameters are missing");if(!e.spatialReference||!t.spatialReference)throw new i.default("geodesic-distance:invalid-parameters","one or both input points do not have a spatial reference");if(!(0,h.aI)(e.spatialReference,t.spatialReference))throw new i.default("geodesic-distance:invalid-parameters","spatial references of input parameters do not match");const{spatialReference:s}=e;if(!v(s))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");if(e.x===t.x&&e.y===t.y)return new y(0,0,0);const o=new y;return _(o,[e.x,e.y],[t.x,t.y],s),o.distance=(0,a.oU)(o.distance,"meters",n),o.azimuth=d(o.azimuth),o.reverseAzimuth=d(o.reverseAzimuth),o}function E(e,t,n){if(!e||null==t||null==n)throw new i.default("point-from-distance:missing-parameters","one or more input parameters are missing or undefined");if(n<0||n>360)throw new i.default("point-from-distance:-of-bounds","azimuth is restricted to angles between, and including, 0\xb0 to 360\xb0 degrees");if(!e.spatialReference)throw new i.default("point-from-distance:missing-spatial-reference","the input point must have a spatial reference");const{spatialReference:a}=e;if(!v(a))throw new i.default("geodesic-distance:not-supported","input geometry spatial reference is not supported");const s=[0,0];return b(s,[e.x,e.y],n,t,a),new o.default({x:s[0],y:s[1],spatialReference:a})}function z(e){return v(e)?e:(0,h.K8)(e)?c.default.WGS84:null}},46818:(e,t,n)=>{n.r(t),n.d(t,{default:()=>d});var i=n(93800),a=n(88102),s=n(42198),o=n(13561),r=n(79953),l=n(48602),c=(n(21265),n(50925),n(14746),n(75269)),u=n(3363),h=n(41317),p=n(87465);let f=class extends p.default{constructor(e){super(e),this.type="input",this.color=new a.default("#00c8c8"),this.viewVisualizationEnabled=!1,this.numSamplesForPreview=50,this.numSamplesPerChunk=500,this.chartFillEnabled=!1,this.chartStrokeOffsetY=-1,this._getQueryElevationDependencies=(0,o.B)(((e,t,n,i,a)=>e?{elevationInfo:e,visibleLayers:t,view:n,stationary:i,spatialReference:a}:null))}get queryElevationDependencies(){const e=this._viewModel?.view;return null==e?null:this._getQueryElevationDependencies(this._elevationInfo,this._visibleLayers,e,e.stationary,e.spatialReference)}get available(){return!this._viewModel?.inputIsSketched}get _elevationInfo(){const e=this._viewModel?.input;return e?(0,h.bh)(e):null}get _visibleLayers(){return this._viewModel?.view?.map?.allLayers?.filter((e=>e.visible)).toArray()??[]}async queryElevation(e,t){let{noDataValue:n,signal:i}=t;const a=this.queryElevationDependencies;if(null==a)throw new Error("ElevationProfileLineInput: no dependencies");const{view:s,elevationInfo:o,spatialReference:r}=a;if("on-the-ground"===o.mode&&"3d"===s.type&&r){const t=await u.GeometryDescriptor.fromGeometry(e).project(r,i);if(!t)return{geometry:e,noDataValue:n};const a=s.elevationProvider;return t.coordinates.forEach((e=>{e.z=a.getElevation(e.x,e.y,0,r,"ground")??0})),{geometry:t.export(),noDataValue:n}}return{geometry:e,noDataValue:n}}attach(e){const t=()=>this._onChange();return(0,s.vE)([super.attach(e),(0,r.watch)((()=>this.queryElevationDependencies),t),(0,r.on)((()=>e.elevationProvider),"elevation-change",t,{onListenerAdd:t,onListenerRemove:t})])}};(0,i._)([(0,l.MZ)({type:a.default,nonNullable:!0})],f.prototype,"color",void 0),(0,i._)([(0,l.MZ)()],f.prototype,"viewVisualizationEnabled",void 0),(0,i._)([(0,l.MZ)()],f.prototype,"queryElevationDependencies",null),(0,i._)([(0,l.MZ)()],f.prototype,"available",null),(0,i._)([(0,l.MZ)()],f.prototype,"_elevationInfo",null),(0,i._)([(0,l.MZ)()],f.prototype,"_visibleLayers",null),f=(0,i._)([(0,c.$)("esri.widgets.ElevationProfile.ElevationProfileLineInput")],f);const d=f}}]);