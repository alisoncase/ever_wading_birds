"use strict";(self.webpackChunkever_wading_birds=self.webpackChunkever_wading_birds||[]).push([[61531],{61531:(t,e,s)=>{s.r(e),s.d(e,{default:()=>d});var i,l=s(93800),n=s(74719),r=s(19455),o=s(82301),a=s(50925),h=s(48602),u=s(32980),c=s(75269),p=s(64884),f=s(82518);let g=i=class extends r.A{static createEmptyBand(t,e){return new(i.getPixelArrayConstructor(t))(e)}static combineBandMasks(t){if(t.length<2)return t[0];const e=t[0].length,s=new Uint8Array(e).fill(255);for(let i=0;i<t.length;i++){const l=t[i];for(let t=0;t<e;t++)l[t]||(s[t]=0)}return s}static getPixelArrayConstructor(t){let e;switch(t){case"u1":case"u2":case"u4":case"u8":e=Uint8Array;break;case"u16":e=Uint16Array;break;case"u32":e=Uint32Array;break;case"s8":e=Int8Array;break;case"s16":e=Int16Array;break;case"s32":e=Int32Array;break;case"f32":case"c64":case"c128":case"unknown":e=Float32Array;break;case"f64":e=Float64Array}return e}constructor(t){super(t),this.width=null,this.height=null,this.pixelType="f32",this.validPixelCount=null,this.mask=null,this.maskIsAlpha=!1,this.premultiplyAlpha=!1,this.statistics=null,this.depthCount=1}castPixelType(t){if(!t)return"f32";let e=t.toLowerCase();return["u1","u2","u4"].includes(e)?e="u8":["unknown","u8","s8","u16","s16","u32","s32","f32","f64"].includes(e)||(e="f32"),e}getPlaneCount(){return this.pixels?.length}addData(t){if(!t.pixels||t.pixels.length!==this.width*this.height)throw new n.default("pixelblock:invalid-or-missing-pixels","add data requires valid pixels array that has same length defined by pixel block width * height");this.pixels||(this.pixels=[]),this.statistics||(this.statistics=[]),this.pixels.push(t.pixels),this.statistics.push(t.statistics??new p.z)}getAsRGBA(){const t=new ArrayBuffer(this.width*this.height*4);switch(this.pixelType){case"s8":case"s16":case"u16":case"s32":case"u32":case"f32":case"f64":this._fillFromNon8Bit(t);break;default:this._fillFrom8Bit(t)}return new Uint8ClampedArray(t)}getAsRGBAFloat(){const t=new Float32Array(this.width*this.height*4);return this._fillFrom32Bit(t),t}updateStatistics(){if(!this.pixels)return;this.statistics=this.pixels.map((t=>function(t,e){let s=1/0,i=-1/0;const l=t.length;let n,r=0;if(null!=e)for(n=0;n<l;n++)e[n]&&(r=t[n],s=r<s?r:s,i=r>i?r:i);else for(n=0;n<l;n++)r=t[n],s=r<s?r:s,i=r>i?r:i;return new p.z(s,i)}(t,this.mask)));const t=this.mask;let e=0;if(null!=t)for(let s=0;s<t.length;s++)t[s]&&e++;else e=this.width*this.height;this.validPixelCount=e}clamp(t){if(!t||"f64"===t||"f32"===t||!this.pixels)return;const[e,s]=(0,f.hP)(t),l=this.pixels,n=this.width*this.height,r=l.length;let o,a,h;const u=[];for(let c=0;c<r;c++){h=i.createEmptyBand(t,n),o=l[c];for(let t=0;t<n;t++)a=o[t],h[t]=a>s?s:a<e?e:a;u.push(h)}this.pixels=u,this.pixelType=t}extractBands(t){const{pixels:e,statistics:s}=this;if(null==t||0===t.length||!e||0===e.length)return this;const l=e.length,n=t.some((t=>t>=e.length)),r=l===t.length&&!t.some(((t,e)=>t!==e));if(n||r)return this;const o=this.bandMasks?.length===l?t.map((t=>this.bandMasks[t])):void 0;let{mask:a,validPixelCount:h}=this;const{width:u,height:c}=this;return o?.length&&(a=i.combineBandMasks(o),h=a.filter((t=>!!t)).length),new i({pixelType:this.pixelType,width:u,height:c,mask:a,bandMasks:o,validPixelCount:h,maskIsAlpha:this.maskIsAlpha,pixels:t.map((t=>e[t])),statistics:s&&t.map((t=>s[t]))})}clone(){const t=new i({width:this.width,height:this.height,pixelType:this.pixelType,maskIsAlpha:this.maskIsAlpha,validPixelCount:this.validPixelCount});let e;null!=this.mask&&(t.mask=new Uint8Array(this.mask)),this.bandMasks&&(t.bandMasks=this.bandMasks.map((t=>new Uint8Array(t))));const s=i.getPixelArrayConstructor(this.pixelType);if(this.pixels&&this.pixels.length>0){t.pixels=[];const i=!!this.pixels[0].slice;for(e=0;e<this.pixels.length;e++)t.pixels[e]=i?this.pixels[e].slice():new s(this.pixels[e])}if(this.statistics)for(t.statistics=[],e=0;e<this.statistics.length;e++)t.statistics[e]=(0,o.clone)(this.statistics[e]);return t.premultiplyAlpha=this.premultiplyAlpha,t}_fillFrom8Bit(t){const{mask:e,maskIsAlpha:s,premultiplyAlpha:i,pixels:l}=this;if(!t||!l?.length)return void a.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");let n,r,o,h;n=r=o=l[0],l.length>=3?(r=l[1],o=l[2]):2===l.length&&(r=l[1]);const u=new Uint32Array(t),c=this.width*this.height;if(n.length===c)if(null!=e&&e.length===c)if(s)for(h=0;h<c;h++){const t=e[h];if(t){const e=t/255;u[h]=i?t<<24|o[h]*e<<16|r[h]*e<<8|n[h]*e:t<<24|o[h]<<16|r[h]<<8|n[h]}}else for(h=0;h<c;h++)e[h]&&(u[h]=255<<24|o[h]<<16|r[h]<<8|n[h]);else for(h=0;h<c;h++)u[h]=255<<24|o[h]<<16|r[h]<<8|n[h];else a.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.")}_fillFromNon8Bit(t){const{pixels:e,mask:s,statistics:i}=this;if(!t||!e?.length)return void a.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The input pixel block is empty.");const l=this.pixelType;let n=1,r=0,o=1;if(i&&i.length>0){for(const t of i)if(null!=t.minValue&&(r=Math.min(r,t.minValue)),null!=t.maxValue&&null!=t.minValue){const e=t.maxValue-t.minValue;o=Math.max(o,e)}n=255/o}else{let t=255;"s8"===l?(r=-128,t=127):"u16"===l?t=65535:"s16"===l?(r=-32768,t=32767):"u32"===l?t=4294967295:"s32"===l?(r=-2147483648,t=2147483647):"f32"===l?(r=-34e38,t=34e38):"f64"===l&&(r=-Number.MAX_VALUE,t=Number.MAX_VALUE),n=255/(t-r)}const h=new Uint32Array(t),u=this.width*this.height;let c,p,f,g,d;if(c=p=f=e[0],c.length!==u)return a.A.getLogger(this).error("getAsRGBA()","Unable to convert to RGBA. The pixelblock is invalid.");if(e.length>=2)if(p=e[1],e.length>=3&&(f=e[2]),null!=s&&s.length===u)for(g=0;g<u;g++)s[g]&&(h[g]=255<<24|(f[g]-r)*n<<16|(p[g]-r)*n<<8|(c[g]-r)*n);else for(g=0;g<u;g++)h[g]=255<<24|(f[g]-r)*n<<16|(p[g]-r)*n<<8|(c[g]-r)*n;else if(null!=s&&s.length===u)for(g=0;g<u;g++)d=(c[g]-r)*n,s[g]&&(h[g]=255<<24|d<<16|d<<8|d);else for(g=0;g<u;g++)d=(c[g]-r)*n,h[g]=255<<24|d<<16|d<<8|d}_fillFrom32Bit(t){const{pixels:e,mask:s}=this;if(!t||!e?.length)return a.A.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The input pixel block is empty.");let i,l,n,r;i=l=n=e[0],e.length>=3?(l=e[1],n=e[2]):2===e.length&&(l=e[1]);const o=this.width*this.height;if(i.length!==o)return a.A.getLogger(this).error("getAsRGBAFloat()","Unable to convert to RGBA. The pixelblock is invalid.");let h=0;if(null!=s&&s.length===o)for(r=0;r<o;r++)t[h++]=i[r],t[h++]=l[r],t[h++]=n[r],t[h++]=1&s[r];else for(r=0;r<o;r++)t[h++]=i[r],t[h++]=l[r],t[h++]=n[r],t[h++]=1}};(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"width",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"height",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"pixelType",void 0),(0,l._)([(0,u.w)("pixelType")],g.prototype,"castPixelType",null),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"validPixelCount",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"mask",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"maskIsAlpha",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"pixels",void 0),(0,l._)([(0,h.MZ)()],g.prototype,"premultiplyAlpha",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"statistics",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"depthCount",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"noDataValues",void 0),(0,l._)([(0,h.MZ)({json:{write:!0}})],g.prototype,"bandMasks",void 0),g=i=(0,l._)([(0,c.$)("esri.layers.support.PixelBlock")],g);const d=g},64884:(t,e,s)=>{s.d(e,{z:()=>i});class i{constructor(){let t=arguments.length>0&&void 0!==arguments[0]?arguments[0]:null,e=arguments.length>1&&void 0!==arguments[1]?arguments[1]:null,s=arguments.length>2&&void 0!==arguments[2]?arguments[2]:null;this.minValue=t,this.maxValue=e,this.noDataValue=s}}},82518:(t,e,s)=>{s.d(e,{$p:()=>u,Sp:()=>c,X1:()=>o,hP:()=>r,yM:()=>h,zw:()=>a});const i=9999999e31,l=2e-7,n={u1:[0,1],u2:[0,3],u4:[0,15],u8:[0,255],s8:[-128,127],u16:[0,65535],s16:[-32768,32767],u32:[0,4294967295],s32:[-2147483648,2147483647],f32:[-34028234663852886e22,34028234663852886e22],f64:[-Number.MAX_VALUE,Number.MAX_VALUE],unknown:void 0,c64:void 0,c128:void 0};function r(t){return n[t]??[-34028234663852886e22,34028234663852886e22]}function o(t,e){return null==t||null==e?"s32":t<0?t>=-128&&e<128?"s8":t>=-32768&&e<32768?"s16":"s32":e<256?"u8":e<65536?"u16":"u32"}function a(t){return(t?.startsWith("s")||t?.startsWith("u"))??!1}function h(t,e,s,i){let[l,n]=r(s);const o=a(s);return o&&(l-=1e-5,n+=1e-5),o?s.startsWith("u")?function(t,e,s,i){const[l,n]=i;for(let r=0;r<e.length;r++)if(e[r]){const i=t[r];i<l||i>n?e[r]=0:s[r]=i+.5|0}}(t,e,i,[l,n]):function(t,e,s,i){const[l,n]=i;for(let r=0;r<e.length;r++)if(e[r]){const i=t[r];i<l||i>n?e[r]=0:s[r]=i+(i>0?.5:-.5)|0}}(t,e,i,[l,n]):function(t,e,s,i){const[l,n]=i;for(let r=0;r<e.length;r++)if(e[r]){const i=t[r];i<l||i>n?e[r]=0:s[r]=i}}(t,e,i,[l,n])}function u(t,e){for(let s=0;s<e.length;s++)e[s]&&isNaN(t[s])&&(e[s]=0,t[s]=0)}function c(t,e,s){if(t.depthCount&&t.depthCount>1)return;const{pixels:n,statistics:o,pixelType:a}=t,h=n[0].length,u=t.bandMasks??[],c=t.mask??new Uint8Array(h).fill(255),p="f32"===a||"f64"===a,f=r(a);let g=!1;for(let r=0;r<n.length;r++){const t="number"==typeof e?e:e[r];if(null==t)continue;const h=o?.[r]?.minValue??f[0],d=o?.[r]?.maxValue??f[1];if(h>t+Number.EPSILON||d<t-Number.EPSILON)continue;const m=u[r]||c.slice(),A=n[r],x=s?.customFloatTolerance;if(p&&0!==x){let e=x;e||(e=Math.abs(t)>=i?l*Math.abs(t):"f32"===a?2**-23:Number.EPSILON);for(let s=0;s<A.length;s++)m[s]&&Math.abs(A[s]-t)<e&&(A[s]=0,m[s]=0,c[s]=0,g=!0)}else for(let e=0;e<A.length;e++)m[e]&&A[e]===t&&(A[e]=0,m[e]=0,c[e]=0,g=!0);u[r]=m}if(g){const e=t.bandMasks||t.pixels.length>1?u:null;s?.matchAllNoData?t.mask=e&&e.length>1?function(t){if(t.length<2)return t[0];const e=t[0].length,s=new Uint8Array(e).fill(0);for(let i=0;i<t.length;i++){const l=t[i];for(let t=0;t<e;t++)l[t]&&(s[t]=255)}return s}(e):c:(t.bandMasks=e,t.mask=c)}g&&"updateStatistics"in t&&t.updateStatistics()}}}]);